<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Diff Visualizer - Compare Code & Config Files Online | Free & Private</title>
    <meta name="description" content="Free online text diff tool to compare code and config files. 100% private - your data never leaves your browser. No signup required. Supports large files up to 10,000+ lines with side-by-side and unified views.">
    <meta name="keywords" content="text diff, code comparison, config file compare, text diff tool, diff text online, compare code files, compare config, file difference">
    <meta name="author" content="Jason Tally">
    <link rel="canonical" href="https://diff.jasontally.com">
    <meta name="url" content="https://diff.jasontally.com">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta name="generator" content="Text Diff Tool v0.1.14">
    <meta name="url" content="https://diff.jasontally.com">
    <meta property="og:title" content="Text Diff Tool - Compare Code & Config Files Online | Free & Private">
    <meta property="og:description" content="Free online text diff tool. 100% private - your data never leaves your browser. No signup required.">
    <meta property="og:url" content="https://diff.jasontally.com">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Text Diff Tool - Compare Code & Config Files Online">
    <meta name="twitter:description" content="Free, private text and code comparison tool. No signup required.">
    <style>
        /* CSS Reset and Base */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.5;
        }
        
        /* CSS Variables */
        :root {
            --bg-color: #f5f5f5;
            --card-bg: white;
            --text-color: #333;
            --text-secondary: #666;
            --text-muted: #999;
            --border-color: #ddd;
            --border-color-strong: #ccc;

            --btn-primary: #000000;
            --btn-primary-hover: #1a1a1a;
            --btn-secondary: #404040;
            --btn-secondary-hover: #505050;
            --btn-tertiary: #5a5a5a;
            --btn-tertiary-hover: #6a6a6a;

            --accent-green: #059669;
            --accent-green-hover: #047857;
            --accent-red: #dc2626;
            --accent-red-hover: #b91c1c;
            --focus-color: #059669;

            /* Added - Teal */
            --diff-added-bg: #E6F5F0;
            --diff-added-text: #009E73;
            /* Removed - Vermillion */
            --diff-removed-bg: #FBEDE6;
            --diff-removed-text: #D55E00;
            /* Modified - Amber */
            --diff-changed-bg: #FDF6E0;
            --diff-changed-text: #B8960C;

            /* Hierarchical inline highlighting - Added (Teal family)
             * Base: #009E73/#E6F5F0 - All levels reference this color
             * Progression: Char (darkest) → Word (medium) → Line (base)
             */
            --diff-added-char-bg: #99d6c4;      /* Darkest - Char level (20% darker than base) */
            --diff-added-char-text: #006b4f;    /* Dark teal text for contrast */
            --diff-added-word-bg: #bfead9;      /* Medium - Word level (10% darker than base) */
            --diff-added-word-text: #008060;    /* Medium teal text for contrast */
            --diff-added-line-bg: #E6F5F0;      /* Lightest - Line level (base background) */
            --diff-added-line-text: #009E73;    /* Standard teal text (base foreground) */

            /* Hierarchical inline highlighting - Removed (Vermillion family)
             * Base: #D55E00/#FBEDE6 - All levels reference this color
             * Progression: Char (darkest) → Word (medium) → Line (base)
             */
            --diff-removed-char-bg: #f5c4a6;    /* Darkest - Char level (20% darker than base) */
            --diff-removed-char-text: #a04000;  /* Dark vermillion text for contrast */
            --diff-removed-word-bg: #f8dcc9;    /* Medium - Word level (10% darker than base) */
            --diff-removed-word-text: #c44a00;  /* Medium vermillion text for contrast */
            --diff-removed-line-bg: #FBEDE6;    /* Lightest - Line level (base background) */
            --diff-removed-line-text: #D55E00;  /* Standard vermillion text (base foreground) */

            /* Block move highlighting - Pure moves (blue family) */
            --diff-block-move-from-fg: #0072B2;    /* Blue foreground - WCAG AA compliant */
            --diff-block-move-from-bg: #E6F0F8;    /* Light blue background */
            --diff-block-move-to-fg: #0072B2;      /* Blue foreground */
            --diff-block-move-to-bg: #E6F0F8;      /* Light blue background */

            /* Block move highlighting - Modified moves (purple family) */
            --diff-block-move-from-modified-fg: #9467BD;  /* Purple foreground - WCAG AA compliant */
            --diff-block-move-from-modified-bg: #F2ECF8;  /* Light purple background */
            --diff-block-move-to-modified-fg: #9467BD;    /* Purple foreground */
            --diff-block-move-to-modified-bg: #F2ECF8;    /* Light purple background */

            --link-color: #2196f3;
            --code-bg: #f3f4f6;
        }
        
        /* Layout */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .header-actions button {
            padding: 6px 14px;
            font-size: 13px;
        }
        
        footer {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }
        
        .footer-actions {
            display: flex;
            gap: 10px;
        }
        
        /* Input Section */
        .input-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .panel-title {
            font-weight: 600;
            color: var(--text-color);
        }
        
        .file-info {
            font-size: 0.875rem;
            color: var(--text-muted);
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid var(--border-color-strong);
            border-radius: 4px;
            font-family: SF Mono, Monaco, "Cascadia Mono", monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            background: var(--card-bg);
            color: var(--text-color);
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--focus-color);
            box-shadow: 0 0 0 2px rgba(5, 150, 105, 0.2);
        }
        
        /* Controls */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:focus {
            outline: 2px solid var(--focus-color);
            outline-offset: 2px;
        }
        
        .btn-primary {
            background: var(--btn-primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--btn-primary-hover);
        }
        
        .btn-secondary {
            background: var(--btn-secondary);
            color: white;
        }
        
        .btn-secondary:hover {
            background: var(--btn-secondary-hover);
        }
        
        .btn-tertiary {
            background: var(--btn-tertiary);
            color: white;
        }
        
        .btn-tertiary:hover {
            background: var(--btn-tertiary-hover);
        }
        
        .mode-toggle {
            display: flex;
            gap: 5px;
        }
        
        .mode-btn {
            padding: 8px 16px;
            background: var(--code-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        
        .mode-btn.active {
            background: var(--btn-primary);
            color: white;
            border-color: var(--btn-primary);
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 5px;
        }
        
        .view-btn {
            padding: 8px 16px;
            background: var(--code-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        
        .view-btn.active {
            background: var(--btn-primary);
            color: white;
            border-color: var(--btn-primary);
        }

        /* Filter Controls */
        .filter-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 8px 12px;
            background: var(--code-bg);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        /* Config Panel */
        .config-panel {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .config-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .config-panel-title {
            font-weight: 600;
            font-size: 16px;
            color: var(--text-color);
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-group label {
            font-weight: 500;
            font-size: 14px;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .config-group input[type="number"] {
            padding: 8px 12px;
            border: 1px solid var(--border-color-strong);
            border-radius: 4px;
            font-size: 14px;
            width: 100%;
            max-width: 200px;
        }

        .config-group input[type="number"]:focus {
            outline: none;
            border-color: var(--focus-color);
            box-shadow: 0 0 0 2px rgba(5, 150, 105, 0.2);
        }

        .config-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--focus-color);
            cursor: pointer;
        }

        .config-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }

        .config-description {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .filter-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
        }

        .filter-label input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: var(--focus-color);
        }

        .filter-label:hover {
            color: var(--btn-primary);
        }

        /* Slider Status */
        .slider-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(5, 150, 105, 0.1);
            border: 1px solid rgba(5, 150, 105, 0.2);
            border-radius: 6px;
            font-size: 14px;
            color: var(--text-color);
        }

        .slider-indicator {
            font-size: 16px;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Stats */
        .stats {
            display: flex;
            gap: 15px;
            font-size: 14px;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stat-value {
            font-weight: 600;
        }
        
        .stat-value.added {
            color: var(--diff-added-text);
        }
        
        .stat-value.removed {
            color: var(--diff-removed-text);
        }

        .stat-value.moved {
            color: var(--diff-block-move-text);
        }
        
        .stat-value.modified {
            color: var(--diff-changed-text);
        }
        
        /* Complexity Limit Warning */
        .limit-warning {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            font-size: 13px;
            color: #856404;
            max-width: 400px;
        }
        
        .limit-warning.hidden {
            display: none;
        }
        
        .warning-icon {
            font-size: 16px;
            flex-shrink: 0;
        }
        
        /* Navigation */
        .navigation {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .nav-btn {
            padding: 8px 16px;
            background: var(--btn-secondary);
            color: white;
        }
        
        .nav-btn:hover {
            background: var(--btn-secondary-hover);
        }
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .change-counter {
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        /* Diff Results */
        .diff-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: var(--border-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            max-height: 600px;
        }

        /* Unified View Styles */
        .unified-container {
            display: block;
            background: var(--border-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            max-height: 600px;
        }
        
        .unified-row {
            display: flex;
            min-height: 1.5em;
            border-bottom: 1px solid #f0f0f0;
            background: var(--card-bg);
        }
        
        .unified-row:last-child {
            border-bottom: none;
        }
        
        .unified-row.added {
            background: var(--diff-added-bg);
        }
        
        .unified-row.added .unified-marker,
        .unified-row.added .unified-line-num,
        .unified-row.added .unified-content {
            color: var(--diff-added-text);
        }
        
        .unified-row.removed {
            background: var(--diff-removed-bg);
        }
        
        .unified-row.removed .unified-marker,
        .unified-row.removed .unified-line-num,
        .unified-row.removed .unified-content {
            color: var(--diff-removed-text);
        }
        
        .unified-row.modified {
            background: var(--diff-changed-bg);
        }
        
        .unified-row.modified .unified-marker,
        .unified-row.modified .unified-line-num,
        .unified-row.modified .unified-content {
            color: var(--diff-changed-text);
        }
        
        .unified-marker {
            width: 30px;
            padding: 2px 8px;
            background: var(--code-bg);
            color: var(--text-muted);
            text-align: center;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
            user-select: none;
            font-weight: bold;
        }
        
        .unified-line-num {
            width: 50px;
            padding: 2px 8px;
            background: var(--code-bg);
            color: var(--text-muted);
            text-align: right;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
            user-select: none;
        }
        
        .unified-content {
            flex: 1;
            padding: 2px 10px;
            white-space: pre;
            overflow-x: auto;
        }
        
        .diff-panel {
            background: var(--card-bg);
            overflow-y: auto;
            max-height: 600px;
            font-family: SF Mono, Monaco, "Cascadia Mono", monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .diff-header {
            display: flex;
            padding: 10px;
            background: var(--code-bg);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .diff-row {
            display: flex;
            min-height: 1.5em;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .diff-row:last-child {
            border-bottom: none;
        }
        
        .line-number {
            width: 50px;
            padding: 2px 8px;
            background: var(--code-bg);
            color: var(--text-muted);
            text-align: right;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
            user-select: none;
        }
        
        .line-number:empty {
            background: transparent;
        }
        
        .line-content {
            flex: 1;
            padding: 2px 10px;
            white-space: pre;
            overflow-x: auto;
        }
        
        .line-content.gap-placeholder {
            visibility: hidden;
        }
        
        /* Diff States */
        .diff-row.added {
            background: var(--diff-added-bg);
        }
        
        .diff-row.added .line-number,
        .diff-row.added .line-content {
            color: var(--diff-added-text);
        }
        
        .diff-row.removed {
            background: var(--diff-removed-bg);
        }
        
        .diff-row.removed .line-number,
        .diff-row.removed .line-content {
            color: var(--diff-removed-text);
        }
        
        .diff-row.modified {
            background: var(--diff-changed-bg);
        }
        
        .diff-row.modified .line-number,
        .diff-row.modified .line-content {
            color: var(--diff-changed-text);
        }
        
        .diff-row.gap {
            background: transparent;
        }
        
        /* Inline Diff - Hierarchical Highlighting */
        /* Line level - Lightest background (base layer) */
        .inline-added-line {
            background-color: var(--diff-added-line-bg);
            color: var(--diff-added-line-text);
            font-weight: 400;
            text-decoration: none;
        }

        .inline-removed-line {
            background-color: var(--diff-removed-line-bg);
            color: var(--diff-removed-line-text);
            font-weight: 400;
            text-decoration: line-through;
        }

        /* Word level - Medium prominence (overrides line) */
        .inline-added-word {
            background-color: var(--diff-added-word-bg);
            color: var(--diff-added-word-text);
            font-weight: 500;
            text-decoration: none;
        }

        .inline-removed-word {
            background-color: var(--diff-removed-word-bg);
            color: var(--diff-removed-word-text);
            font-weight: 500;
            text-decoration: line-through;
        }

        /* Char level - Darkest/most prominent (overrides word and line) */
        .inline-added-char {
            background-color: var(--diff-added-char-bg);
            color: var(--diff-added-char-text);
            font-weight: 600;
            text-decoration: none;
        }

        .inline-removed-char {
            background-color: var(--diff-removed-char-bg);
            color: var(--diff-removed-char-text);
            font-weight: 600;
            text-decoration: line-through;
        }

        /* Nested word highlighting inside comments/strings - Uses Teal/Vermillion family */
        .inline-added-word.nested {
            background-color: #bfead9; /* Uses same medium teal as word level */
            color: #008060; /* Matches word level text */
            font-weight: 500;
            text-decoration: none;
            border-radius: 2px;
            padding: 0 2px;
        }

        .inline-removed-word.nested {
            background-color: #f8dcc9; /* Uses same medium vermillion as word level */
            color: #c44a00; /* Matches word level text */
            font-weight: 500;
            text-decoration: line-through;
            border-radius: 2px;
            padding: 0 2px;
        }

        /* Fallback unchanged */
        .inline-unchanged {
            background-color: transparent;
            color: inherit;
        }

        /* Block Move Indicators - Pure Moves (Blue) */
        .block-moved-from {
            background: var(--diff-block-move-from-bg);
            border-left: 3px solid var(--diff-block-move-from-fg);
        }

        .block-moved-from .unified-marker,
        .block-moved-from .line-number {
            color: var(--diff-block-move-from-fg);
            font-weight: bold;
        }

        .block-moved-to {
            background: var(--diff-block-move-to-bg);
            border-left: 3px solid var(--diff-block-move-to-fg);
        }

        .block-moved-to .unified-marker,
        .block-moved-to .line-number {
            color: var(--diff-block-move-to-fg);
            font-weight: bold;
        }

        /* Block Move Indicators - Modified Moves (Purple) */
        .block-moved-from-modified {
            background: var(--diff-block-move-from-modified-bg);
            border-left: 3px solid var(--diff-block-move-from-modified-fg);
        }

        .block-moved-from-modified .unified-marker,
        .block-moved-from-modified .line-number {
            color: var(--diff-block-move-from-modified-fg);
            font-weight: bold;
        }

        .block-moved-to-modified {
            background: var(--diff-block-move-to-modified-bg);
            border-left: 3px solid var(--diff-block-move-to-modified-fg);
        }

        .block-moved-to-modified .unified-marker,
        .block-moved-to-modified .line-number {
            color: var(--diff-block-move-to-modified-fg);
            font-weight: bold;
        }

        /* Legacy class support - map to new classes */
        .block-moved-source,
        .block-moved-from,
        .block-moved-from-modified {
            background: var(--diff-block-move-from-bg);
            border-left: 3px solid var(--diff-block-move-from-fg);
        }

        .block-moved-destination,
        .block-moved-to,
        .block-moved-to-modified {
            background: var(--diff-block-move-to-bg);
            border-left: 3px solid var(--diff-block-move-to-fg);
        }

        /* Block move indicator styling */
        .block-moved-indicator {
            position: relative;
            cursor: help;
        }

        .block-move-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .block-moved-indicator:hover .block-move-tooltip {
            opacity: 1;
        }

        /* Syntax Highlighting for Unchanged Lines */
        .syntax-keyword {
            color: #0000ff;
            font-weight: bold;
        }
        
        .syntax-string {
            color: #008000;
        }
        
        .syntax-number {
            color: #098658;
        }
        
        .syntax-comment {
            color: #008000;
            font-style: italic;
        }
        
        .syntax-identifier {
            color: #001080;
        }
        
        .syntax-operator {
            color: #0000ff;
        }
        
        .syntax-delimiter {
            color: #000000;
        }
        
        .syntax-other {
            color: inherit;
        }

        /* Dark theme syntax highlighting */
        @media (prefers-color-scheme: dark) {
            .syntax-keyword {
                color: #569cd6;
            }
            
            .syntax-string {
                color: #ce9178;
            }
            
            .syntax-number {
                color: #b5cea8;
            }
            
            .syntax-comment {
                color: #6a9955;
                font-style: italic;
            }
            
            .syntax-identifier {
                color: #9cdcfe;
            }
            
            .syntax-operator {
                color: #d4d4d4;
            }
            
            .syntax-delimiter {
                color: #d4d4d4;
            }
        }
        
        /* Progress Modal */
        .progress-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .progress-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border-color);
            border-top-color: var(--focus-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        /* Utility Classes */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Drag and Drop */
        .panel.drag-over {
            border-color: var(--focus-color);
            background: rgba(5, 150, 105, 0.05);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            
            /* Ensure minimum touch target size for accessibility (44x44px) */
            button, .mode-btn, .view-btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            .filter-label {
                min-height: 44px;
                display: flex;
                align-items: center;
            }
            
            .diff-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                justify-content: center;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            /* View toggle is available on all screen sizes */
            .view-toggle {
                display: flex;
            }
            
            /* Unified view adjustments for mobile */
            .unified-marker {
                width: 25px;
                padding: 2px 4px;
            }
            
            .unified-line-num {
                width: 40px;
                padding: 2px 4px;
            }
        }

        /* Print Styles */
        @media print {
            /* Hide interactive elements */
            .header-actions,
            .controls,
            .navigation,
            .input-section,
            .progress-modal {
                display: none !important;
            }

            /* Page setup */
            body {
                background: white;
                color: black;
                font-size: 10pt;
                line-height: 1.3;
            }

            .container {
                max-width: 100%;
                padding: 0.5in;
                margin: 0;
            }

            /* Ensure diff content is visible */
            .diff-container,
            .unified-container {
                display: block !important;
                max-height: none;
                border: 1px solid #ccc;
                page-break-inside: avoid;
            }

            /* Show unified view for printing */
            .diff-container {
                grid-template-columns: 1fr;
            }

            /* Force print-friendly colors */
            .diff-row.added {
                background-color: #e6ffe6 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .diff-row.added .line-content {
                color: #006600 !important;
            }

            .diff-row.removed {
                background-color: #ffe6e6 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .diff-row.removed .line-content {
                color: #cc0000 !important;
            }

            .diff-row.modified {
                background-color: #fff5e6 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .diff-row.modified .line-content {
                color: #b35900 !important;
            }

            .unified-row.added {
                background-color: #e6ffe6 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .unified-row.added .unified-content,
            .unified-row.added .unified-marker {
                color: #006600 !important;
            }

            .unified-row.removed {
                background-color: #ffe6e6 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .unified-row.removed .unified-content,
            .unified-row.removed .unified-marker {
                color: #cc0000 !important;
            }

            .unified-row.modified {
                background-color: #fff5e6 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .unified-row.modified .unified-content,
            .unified-row.modified .unified-marker {
                color: #b35900 !important;
            }

            /* Page breaks */
            .diff-row {
                page-break-inside: avoid;
                border-bottom: 1px solid #ddd;
            }

            .unified-row {
                page-break-inside: avoid;
                border-bottom: 1px solid #ddd;
            }

            /* Header styling */
            header {
                border-bottom: 2px solid #333;
                margin-bottom: 0.5in;
                padding-bottom: 0.2in;
            }

            h1 {
                font-size: 16pt;
            }

            /* Line numbers and content */
            .line-number,
            .unified-line-num {
                background-color: #f0f0f0 !important;
                color: #333 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .diff-header {
                background-color: #f0f0f0 !important;
                border-bottom: 2px solid #333;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* Hide gap placeholders */
            .gap-placeholder {
                display: none;
            }

            /* Ensure inline diffs are visible */
            .inline-added {
                background-color: #e6ffe6 !important;
                color: #006600 !important;
                font-weight: bold;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .inline-removed {
                background-color: #ffe6e6 !important;
                color: #cc0000 !important;
                text-decoration: line-through;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* Add print header with timestamp */
            .diff-panel::before,
            .unified-container::before {
                content: "Text Diff Comparison - Printed " attr(data-print-date);
                display: block;
                font-size: 8pt;
                color: #666;
                margin-bottom: 10px;
                text-align: right;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Text Diff Visualizer</h1>
            <div class="header-actions">
                <button class="btn-tertiary" aria-label="Toggle configuration panel" aria-expanded="false" id="config-toggle-btn">Settings</button>
                <button class="btn-tertiary" aria-label="View help documentation" id="help-btn">Help</button>
                <button class="btn-tertiary" aria-label="About this application" id="about-btn">About</button>
            </div>
        </header>
        
        <main>
        
        <!-- Config Panel -->
        <section id="config-panel" class="config-panel hidden" aria-label="Configuration settings" aria-hidden="true" tabindex="-1">
            <div class="config-panel-header">
                <span class="config-panel-title">Advanced Settings</span>
                <button class="btn-tertiary" aria-label="Close configuration panel" id="config-close-btn">&times;</button>
            </div>
            <div class="config-grid">
                <div class="config-group">
                    <label for="max-lines" id="max-lines-label">Max Lines</label>
                    <input type="number" id="max-lines" min="1000" max="200000" step="1000" aria-labelledby="max-lines-label" aria-describedby="max-lines-desc">
                    <span class="config-description" id="max-lines-desc">Maximum lines per file (1,000-200,000). Exceeding this falls back to fast mode.</span>
                </div>
                <div class="config-group">
                    <label for="max-graph-vertices" id="max-graph-vertices-label">Max Graph Vertices</label>
                    <input type="number" id="max-graph-vertices" min="1000" max="1000000" step="1000" aria-labelledby="max-graph-vertices-label" aria-describedby="max-graph-vertices-desc">
                    <span class="config-description" id="max-graph-vertices-desc">Maximum vertices for graph-based diff (1,000-1,000,000). Exceeding this falls back to fast mode.</span>
                </div>
                <div class="config-group">
                    <label for="max-bytes" id="max-bytes-label">Byte Limit</label>
                    <input type="number" id="max-bytes" min="100000" max="10000000" step="100000" aria-labelledby="max-bytes-label" aria-describedby="max-bytes-desc">
                    <span class="config-description" id="max-bytes-desc">Maximum file size in bytes (100KB-10MB)</span>
                </div>
                <div class="config-group">
                    <label for="ast-line-threshold" id="ast-line-threshold-label">AST Threshold</label>
                    <input type="number" id="ast-line-threshold" min="100" max="10000" step="100" aria-labelledby="ast-line-threshold-label" aria-describedby="ast-line-threshold-desc">
                    <span class="config-description" id="ast-line-threshold-desc">Line threshold for AST analysis (100-10,000)</span>
                </div>
                <div class="config-group">
                    <label for="enable-ast" id="enable-ast-label">
                        <input type="checkbox" id="enable-ast" aria-labelledby="enable-ast-label enable-ast-desc">
                        Enable AST
                    </label>
                    <span class="config-description" id="enable-ast-desc">Parse code structure for semantic comparison</span>
                </div>
                <div class="config-group">
                    <label for="enable-graph-diff" id="enable-graph-diff-label">
                        <input type="checkbox" id="enable-graph-diff" aria-labelledby="enable-graph-diff-label enable-graph-diff-desc">
                        Enable Graph Diff
                    </label>
                    <span class="config-description" id="enable-graph-diff-desc">Use graph algorithms for complex diffs</span>
                </div>
                <div class="config-group">
                    <label for="enable-fast-mode" id="enable-fast-mode-label">
                        <input type="checkbox" id="enable-fast-mode" aria-labelledby="enable-fast-mode-label enable-fast-mode-desc">
                        Enable Fast Mode
                    </label>
                    <span class="config-description" id="enable-fast-mode-desc">When disabled, always generates detailed word/character diffs even for large files (may be slower)</span>
                </div>
                <div class="config-group">
                    <label for="normalize-delimiters" id="normalize-delimiters-label">
                        <input type="checkbox" id="normalize-delimiters" aria-labelledby="normalize-delimiters-label normalize-delimiters-desc">
                        Normalize Delimiters
                    </label>
                    <span class="config-description" id="normalize-delimiters-desc">Normalize whitespace inside delimiters (parentheses, brackets, braces) for better comparison</span>
                </div>
                <div class="config-group">
                    <label for="correct-sliders" id="correct-sliders-label">
                        <input type="checkbox" id="correct-sliders" aria-labelledby="correct-sliders-label correct-sliders-desc">
                        Correct Sliders
                    </label>
                    <span class="config-description" id="correct-sliders-desc">Automatically adjust ambiguous diff positions for cleaner, more natural diff alignment</span>
                </div>
            </div>
            <div class="config-actions">
                <button class="btn-primary" aria-label="Save configuration settings" id="save-config-btn">Save Settings</button>
                <button class="btn-secondary" aria-label="Reset to default settings" id="reset-config-btn">Reset to Defaults</button>
            </div>
        </section>
        
        <!-- Input Section -->
        <section class="input-section" aria-label="Text input panels">
            <div class="panel" id="previous-panel-drop">
                <div class="panel-header">
                    <span class="panel-title">Previous Version</span>
                    <span class="file-info" id="previous-file-info"></span>
                </div>
                <label for="previous-text" class="sr-only">Previous version text</label>
                <textarea 
                    id="previous-text" 
                    placeholder="Paste previous version text here, or drop a file..."
                    aria-label="Previous version text input"
                ></textarea>
            </div>
            
            <div class="panel" id="current-panel-drop">
                <div class="panel-header">
                    <span class="panel-title">Current Version</span>
                    <span class="file-info" id="current-file-info"></span>
                </div>
                <label for="current-text" class="sr-only">Current version text</label>
                <textarea 
                    id="current-text" 
                    placeholder="Paste current version text here, or drop a file..."
                    aria-label="Current version text input"
                ></textarea>
            </div>
        </section>
        
        <!-- Controls -->
        <section class="controls" aria-label="Comparison controls">
            <div class="control-group">
                <button id="compare-btn" class="btn-primary" aria-label="Compare the two text versions">
                    Compare
                </button>
                <button id="clear-btn" class="btn-secondary" aria-label="Clear both text panels">
                    Clear Both
                </button>
                <button id="swap-btn" class="btn-secondary" aria-label="Swap the two text panels">
                    Swap
                </button>
            </div>

            <div class="control-group mode-toggle" data-testid="mode-toggle">
                <button class="mode-btn active" data-mode="lines" aria-label="Toggle line-level highlighting" aria-pressed="true" data-testid="mode-btn-lines">Line</button>
                <button class="mode-btn active" data-mode="words" aria-label="Toggle word-level highlighting" aria-pressed="true" data-testid="mode-btn-words">Word</button>
                <button class="mode-btn active" data-mode="chars" aria-label="Toggle character-level highlighting" aria-pressed="true" data-testid="mode-btn-chars">Char</button>
            </div>

            <div class="control-group view-toggle" data-testid="view-toggle">
                <button class="view-btn active" data-view="split" aria-label="Show side-by-side diff view" data-testid="view-btn-split">Split</button>
                <button class="view-btn" data-view="unified" aria-label="Show unified diff view" data-testid="view-btn-unified">Unified</button>
            </div>

            <div class="control-group filter-controls">
                <label class="filter-label" for="ignore-whitespace">
                    <input type="checkbox" id="ignore-whitespace" aria-label="Ignore whitespace changes">
                    Ignore Whitespace
                </label>
                <label class="filter-label" for="ignore-comments">
                    <input type="checkbox" id="ignore-comments" aria-label="Ignore comment changes">
                    Ignore Comments
                </label>
            </div>
            
            <div class="slider-status" id="slider-status" style="display: none;">
                <span class="slider-indicator" id="slider-indicator">⚡</span>
                <span id="slider-message">Auto-corrected 0 sliders</span>
            </div>
            
            <div class="stats" id="stats" aria-live="polite" aria-atomic="true" data-testid="diff-stats">
                <div class="stat" data-testid="stat-added-container">
                    <span>Added:</span>
                    <span class="stat-value added" id="stat-added" data-testid="stat-added">0</span>
                </div>
                <div class="stat" data-testid="stat-removed-container">
                    <span>Removed:</span>
                    <span class="stat-value removed" id="stat-removed" data-testid="stat-removed">0</span>
                </div>
                <div class="stat" data-testid="stat-modified-container">
                    <span>Modified:</span>
                    <span class="stat-value modified" id="stat-modified" data-testid="stat-modified">0</span>
                </div>
                <div class="stat" data-testid="stat-moved-container">
                    <span>Moved:</span>
                    <span class="stat-value moved" id="stat-moved" data-testid="stat-moved">0</span>
                </div>
                <div id="slider-stat" style="display: none;" data-testid="stat-sliders-container">
                    <span>Sliders:</span>
                    <span class="stat-value" id="stat-sliders" data-testid="stat-sliders">0</span>
                </div>
            </div>
            
            <!-- Complexity Limit Warning -->
            <div id="limit-warning" class="limit-warning hidden" role="alert" aria-live="polite">
                <span class="warning-icon">⚠️</span>
                <span id="limit-warning-text"></span>
            </div>
            
            <div class="control-group" id="export-controls" style="display: none;" data-testid="export-controls">
                <button id="copy-btn" class="btn-secondary" aria-label="Copy unified diff to clipboard" data-testid="copy-btn">
                    Copy to Clipboard
                </button>
                <button id="download-btn" class="btn-secondary" aria-label="Download diff as patch file" data-testid="download-btn">
                    Download .patch
                </button>
            </div>
        </section>
        
        <!-- Navigation -->
        <section class="navigation" id="navigation-section" style="display: none;" aria-label="Change navigation" data-testid="navigation-section">
            <button id="prev-change-btn" class="nav-btn" aria-label="Go to previous change" data-testid="prev-change-btn">
                ← Prev
            </button>
            <span class="change-counter" id="change-counter" data-testid="change-counter">0 of 0</span>
            <button id="next-change-btn" class="nav-btn" aria-label="Go to next change" data-testid="next-change-btn">
                Next →
            </button>
        </section>
        
        <!-- Diff Results - Split View -->
        <section class="diff-container" id="diff-container" style="display: none;" aria-label="Diff results" data-testid="diff-container">
            <div class="diff-panel" id="previous-diff-panel" aria-label="Previous version diff" data-testid="previous-diff-panel">
                <div class="diff-header" data-testid="previous-diff-header">
                    <span style="flex: 1;">Previous</span>
                </div>
                <div id="previous-diff-content" data-testid="previous-diff-content"></div>
            </div>
            <div class="diff-panel" id="current-diff-panel" aria-label="Current version diff" data-testid="current-diff-panel">
                <div class="diff-header" data-testid="current-diff-header">
                    <span style="flex: 1;">Current</span>
                </div>
                <div id="current-diff-content" data-testid="current-diff-content"></div>
            </div>
        </section>

        <!-- Diff Results - Unified View -->
        <section class="unified-container" id="unified-container" style="display: none;" aria-label="Unified diff results" data-testid="unified-container">
            <div class="diff-panel" id="unified-diff-panel" aria-label="Unified diff view" data-testid="unified-diff-panel">
                <div class="diff-header" data-testid="unified-diff-header">
                    <span style="flex: 1;">Unified Diff</span>
                </div>
                <div id="unified-diff-content"></div>
            </div>
        </section>
    </main>
    
    <footer>
        <div class="footer-copyright" style="font-size: 14px; color: var(--text-secondary);">
            Free text diff tool - Compare code & config files privately
        </div>
    </footer>
    </div>
    
    <!-- Progress Modal (hidden by default) -->
    <div id="progress-modal" class="progress-modal hidden" role="dialog" aria-modal="true" aria-label="Comparing text">
        <div class="progress-content">
            <div class="spinner" aria-hidden="true"></div>
            <p>Analyzing differences...</p>
        </div>
    </div>

    <script type="module">
        console.log('[Main] Script module starting...');
        
        // Import worker template from src/diff-worker.js
        // Cache busting version: 9 - forces browser to reload when updated
        import { WORKER_CODE_TEMPLATE } from './src/diff-worker.js?v=9';
        console.log('[Main] diff-worker imported');
        
        // Import language detection for syntax highlighting
        import { detectLanguage } from './src/language-detect.js?v=9';
        console.log('[Main] language-detect imported');
        
        // Import module validation system
        // Cache busting version: 9 - forces browser to reload when updated
        import { 
            validateWorkerModule, 
            createEnhancedErrorMessage, 
            getGracefulDegradationStrategy,
            addCacheBusting 
        } from './src/module-validator.js?v=9';
        console.log('[Main] module-validator imported');
        
        // ============================================================================
        // Error Handling Utilities - Always log to console AND show user messages
        // ============================================================================
        
        /**
         * Centralized error handler - logs to console and shows user-friendly message
         * @param {string} context - Where the error occurred (e.g., 'Comparison', 'Render')
         * @param {Error|string} error - The error object or message
         * @param {Object} details - Additional details to log
         */
        function handleError(context, error, details = {}) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            const fullMessage = `[${context}] ${errorMessage}`;
            
            // Always log to console with full details
            console.error(fullMessage, {
                context,
                error,
                details,
                stack: error instanceof Error ? error.stack : 'No stack trace',
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                url: window.location.href
            });
            
            // Show user-friendly alert (but only if not in test mode)
            if (!window.__TEST_MODE__) {
                alert(`${context} failed: ${errorMessage}`);
            }
            
            return fullMessage;
        }
        
        /**
         * Validation helper - checks if comparison result is valid
         * @param {Object} result - The comparison result
         * @returns {Object} { isValid: boolean, error: string|null }
         */
        function validateComparisonResult(result) {
            if (!result) {
                const error = 'Comparison returned null/undefined result';
                console.error('[Validation] Invalid result:', error, { result });
                return { isValid: false, error };
            }
            
            if (!Array.isArray(result.results)) {
                const error = `Comparison result is not an array: ${typeof result.results}`;
                console.error('[Validation] Invalid result structure:', error, { result });
                return { isValid: false, error };
            }
            
            if (result.results.length === 0) {
                // Empty results might be valid for empty files, but log a warning
                console.warn('[Validation] Comparison returned empty results array', { result });
            }
            
            // Check for undefined/null values in results
            const invalidItems = result.results.filter((item, idx) => {
                if (!item || typeof item !== 'object') {
                    console.error(`[Validation] Invalid item at index ${idx}:`, item);
                    return true;
                }
                if (typeof item.value !== 'string') {
                    console.error(`[Validation] Item at index ${idx} has invalid value:`, item);
                    return true;
                }
                return false;
            });
            
            if (invalidItems.length > 0) {
                const error = `${invalidItems.length} invalid items found in results`;
                console.error('[Validation] Result validation failed:', error);
                return { isValid: false, error };
            }
            
            console.log('[Validation] Result validation passed:', {
                resultCount: result.results.length,
                hasStats: !!result.stats,
                hasLimitInfo: !!result.limitInfo
            });
            
            return { isValid: true, error: null };
        }
        
        /**
         * Check if comparison might have timed out or hung
         * @param {number} startTime - Performance.now() timestamp when comparison started
         * @returns {boolean} True if comparison appears to have timed out
         */
        function checkForTimeout(startTime) {
            const elapsed = performance.now() - startTime;
            const TIMEOUT_THRESHOLD = 30000; // 30 seconds
            
            if (elapsed > TIMEOUT_THRESHOLD) {
                console.error('[Timeout] Comparison appears to have timed out:', {
                    elapsed: `${(elapsed / 1000).toFixed(2)}s`,
                    threshold: `${TIMEOUT_THRESHOLD / 1000}s`
                });
                return true;
            }
            return false;
        }
        
        // ============================================================================
        // DiffWorker Class - Manages Web Worker for diff calculations
        // ============================================================================
        class DiffWorker {
            constructor(workerCodeTemplate) {
                console.log('[DiffWorker] Constructor called');
                this.worker = null;
                this.pendingPromise = null;
                this.onComplete = null;
                this.workerCodeTemplate = workerCodeTemplate;
                this.validationResult = null;
                this.init();
            }
            
            init() {
                console.log('[DiffWorker] init() called');
                try {
                    // Resolve the base URL dynamically
                    const baseUrl = window.location.origin;
                    
                    // Prepare worker code with cache busting
                    // IMPORTANT: Trim leading/trailing whitespace to prevent parse errors
                    let workerCode = this.workerCodeTemplate.trim();
                    
                    // Replace all relative imports with absolute URLs and cache busting
                    // Cache busting version: 12 - forces browser to reload modules when updated
workerCode = workerCode.replace(
                        "from './diff-algorithms.js?v=13'",
                        `from '${baseUrl}/src/diff-algorithms.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './language-detect.js?v=13'",
                        `from '${baseUrl}/src/language-detect.js?v=13'`
                    );
                    // Also handle old versions that might be cached
                    workerCode = workerCode.replace(
                        "from './diff-algorithms.js?v=11'",
                        `from '${baseUrl}/src/diff-algorithms.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './language-detect.js?v=11'",
                        `from '${baseUrl}/src/language-detect.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './diff-algorithms.js?v=10'",
                        `from '${baseUrl}/src/diff-algorithms.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './language-detect.js?v=10'",
                        `from '${baseUrl}/src/language-detect.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './diff-algorithms.js?v=9'",
                        `from '${baseUrl}/src/diff-algorithms.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './language-detect.js?v=9'",
                        `from '${baseUrl}/src/language-detect.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './diff-algorithms.js?v=8'",
                        `from '${baseUrl}/src/diff-algorithms.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './language-detect.js?v=8'",
                        `from '${baseUrl}/src/language-detect.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './diff-algorithms.js?v=7'",
                        `from '${baseUrl}/src/diff-algorithms.js?v=11'`
                    );
                    workerCode = workerCode.replace(
                        "from './tree-sitter-loader.js?v=6'",
                        `from '${baseUrl}/src/tree-sitter-loader.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './language-detect.js?v=6'",
                        `from '${baseUrl}/src/language-detect.js?v=9'`
                    );
                    workerCode = workerCode.replace(
                        "from './tree-sitter-loader.js?v=5'",
                        `from '${baseUrl}/src/tree-sitter-loader.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './language-detect.js?v=5'",
                        `from '${baseUrl}/src/language-detect.js?v=9'`
                    );
                    workerCode = workerCode.replace(
                        "from './tree-sitter-loader.js?v=3'",
                        `from '${baseUrl}/src/tree-sitter-loader.js?v=13'`
                    );
                    workerCode = workerCode.replace(
                        "from './language-detect.js?v=3'",
                        `from '${baseUrl}/src/language-detect.js?v=9'`
                    );
                    // Handle block-move-detector.js imports with cache busting
                    workerCode = workerCode.replace(
                        "from './block-move-detector.js?v=13'",
                        `from '${baseUrl}/src/block-move-detector.js?v=13'`
                    );
                    // Also handle unversioned block-move-detector.js
                    workerCode = workerCode.replace(
                        "from './block-move-detector.js'",
                        `from '${baseUrl}/src/block-move-detector.js?v=13'`
                    );
                    
                    // Validate worker module before creation
                    console.log('[DiffWorker] Worker code length:', workerCode.length);
                    this.validationResult = validateWorkerModule(workerCode, baseUrl);
                    
                    // Log validation results for debugging
                    console.log('[DiffWorker] Module validation:', {
                        isValid: this.validationResult.isValid,
                        errors: this.validationResult.errors,
                        warnings: this.validationResult.warnings,
                        compatibility: this.validationResult.compatibility
                    });
                    
                    // If validation fails, try graceful degradation
                    if (!this.validationResult.isValid) {
                        console.warn('[DiffWorker] Validation failed, checking degradation strategy...');
                        const strategy = this.validationResult.degradationStrategy;
                        
                        if (!strategy.canProceed) {
                            console.error('[DiffWorker] Worker code that failed validation:');
                            console.error(workerCode.substring(0, 1000) + '...');
                            throw new Error(`Worker initialization failed: ${strategy.message}`);
                        }
                        
                        console.info(`[DiffWorker] Using degradation strategy: ${strategy.strategy}`);
                        // For now, we'll still try to create the worker with potential reduced functionality
                    }
                    
                    // Log warnings if any
                    if (this.validationResult.warnings.length > 0) {
                        console.warn('[DiffWorker] Validation warnings:', this.validationResult.warnings);
                    }
                    
                    // Create worker from Blob URL
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const blobUrl = URL.createObjectURL(blob);
                    this.worker = new Worker(blobUrl, { type: 'module' });
                    
                    this.worker.onmessage = (e) => {
                        if (e.data.type === 'complete') {
                            if (this.pendingPromise) {
                                this.pendingPromise.resolve(e.data);
                                this.pendingPromise = null;
                            }
                            if (this.onComplete) {
                                this.onComplete(e.data);
                            }
                        } else if (e.data.type === 'error') {
                            if (this.pendingPromise) {
                                this.pendingPromise.reject(new Error(e.data.error));
                                this.pendingPromise = null;
                            }
                        }
                    };
                    
                    this.worker.onerror = (error) => {
                        // Log full error details for debugging
                        console.error('[DiffWorker] Raw worker error:', error);
                        console.error('[DiffWorker] Error details:', {
                            message: error?.message,
                            filename: error?.filename,
                            lineno: error?.lineno,
                            colno: error?.colno,
                            error: error?.error
                        });
                        
                        // Create enhanced error message with context
                        const enhancedError = createEnhancedErrorMessage(error, {
                            isWorker: true,
                            importPaths: this.validationResult?.paths?.paths || [],
                            compatibility: this.validationResult?.compatibility || {}
                        });
                        
                        console.error('[DiffWorker] Worker error:', enhancedError);
                        if (this.pendingPromise) {
                            this.pendingPromise.reject(new Error(enhancedError));
                            this.pendingPromise = null;
                        }
                    };
                } catch (error) {
                    // Create enhanced error message for initialization failure
                    const enhancedError = createEnhancedErrorMessage(error, {
                        isWorker: true,
                        compatibility: this.validationResult?.compatibility || {}
                    });
                    
                    console.error('[DiffWorker] Failed to initialize worker:', enhancedError);
                    
                    // Try graceful degradation strategy
                    if (this.validationResult) {
                        const strategy = getGracefulDegradationStrategy({
                            isWorker: true,
                            importPaths: this.validationResult.paths?.paths || []
                        });
                        
                        console.error('[DiffWorker] Degradation strategy:', strategy);
                        throw new Error(`${enhancedError} ${strategy.message}`);
                    } else {
                        throw enhancedError;
                    }
                }
            }
            
            compare(oldText, newText, options = {}) {
                if (!this.worker) {
                    return Promise.reject(new Error('Worker not initialized'));
                }
                
                return new Promise((resolve, reject) => {
                    this.pendingPromise = { resolve, reject };
                    this.worker.postMessage({ oldText, newText, options });
                });
            }
            
            /**
             * Get the validation result from worker initialization
             * @returns {Object|null} Validation result or null if not validated
             */
            getValidationResult() {
                return this.validationResult;
            }
            
            /**
             * Check if worker is fully functional (initialized and validated)
             * @returns {boolean} True if worker is ready for use
             */
            isReady() {
                return this.worker !== null && 
                       this.validationResult !== null &&
                       (this.validationResult.isValid || this.validationResult.degradationStrategy?.canProceed);
            }
            
            /**
             * Get worker health status for debugging
             * @returns {Object} Health status information
             */
            getHealthStatus() {
                return {
                    workerExists: this.worker !== null,
                    validationComplete: this.validationResult !== null,
                    isReady: this.isReady(),
                    isValid: this.validationResult?.isValid || false,
                    hasWarnings: this.validationResult?.warnings?.length > 0 || false,
                    errorCount: this.validationResult?.errors?.length || 0,
                    warningCount: this.validationResult?.warnings?.length || 0,
                    compatibility: this.validationResult?.compatibility || {},
                    degradationStrategy: this.validationResult?.degradationStrategy?.strategy || 'none'
                };
            }
            
            terminate() {
                if (this.worker) {
                    this.worker.terminate();
                    this.worker = null;
                }
            }
        }
        
        // ============================================================================
        // Main Application Logic
        // ============================================================================
        
        // DOM Elements
        const previousText = document.getElementById('previous-text');
        const currentText = document.getElementById('current-text');
        const previousFileInfo = document.getElementById('previous-file-info');
        const currentFileInfo = document.getElementById('current-file-info');
        const compareBtn = document.getElementById('compare-btn');
        const clearBtn = document.getElementById('clear-btn');
        const swapBtn = document.getElementById('swap-btn');
        const progressModal = document.getElementById('progress-modal');
        const diffContainer = document.getElementById('diff-container');
        const navigationSection = document.getElementById('navigation-section');
        const previousDiffPanel = document.getElementById('previous-diff-panel');
        const currentDiffPanel = document.getElementById('current-diff-panel');
        const previousDiffContent = document.getElementById('previous-diff-content');
        const currentDiffContent = document.getElementById('current-diff-content');
        const statAdded = document.getElementById('stat-added');
        const statRemoved = document.getElementById('stat-removed');
        const statModified = document.getElementById('stat-modified');
        const statMoved = document.getElementById('stat-moved');
        const prevChangeBtn = document.getElementById('prev-change-btn');
        const nextChangeBtn = document.getElementById('next-change-btn');
        const changeCounter = document.getElementById('change-counter');
        const modeButtons = document.querySelectorAll('.mode-btn');
        const viewButtons = document.querySelectorAll('.view-btn');
        const exportControls = document.getElementById('export-controls');
        const copyBtn = document.getElementById('copy-btn');
        const downloadBtn = document.getElementById('download-btn');
        const ignoreWhitespaceCheckbox = document.getElementById('ignore-whitespace');
        const ignoreCommentsCheckbox = document.getElementById('ignore-comments');
        const unifiedContainer = document.getElementById('unified-container');
        const unifiedDiffContent = document.getElementById('unified-diff-content');
        const configPanel = document.getElementById('config-panel');
        const configToggleBtn = document.getElementById('config-toggle-btn');
        const configCloseBtn = document.getElementById('config-close-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        const resetConfigBtn = document.getElementById('reset-config-btn');
        const helpBtn = document.getElementById('help-btn');
        const aboutBtn = document.getElementById('about-btn');
        const maxLinesInput = document.getElementById('max-lines');
        const maxVerticesInput = document.getElementById('max-graph-vertices');
        const maxBytesInput = document.getElementById('max-bytes');
        const astThresholdInput = document.getElementById('ast-line-threshold');
        const enableAstCheckbox = document.getElementById('enable-ast');
        const enableGraphDiffCheckbox = document.getElementById('enable-graph-diff');
        const enableFastModeCheckbox = document.getElementById('enable-fast-mode');
        const normalizeDelimitersCheckbox = document.getElementById('normalize-delimiters');
        const correctSlidersCheckbox = document.getElementById('correct-sliders');
        const sliderStat = document.getElementById('slider-stat');
        const statSliders = document.getElementById('stat-sliders');
        const sliderStatus = document.getElementById('slider-status');
        const sliderIndicator = document.getElementById('slider-indicator');
        const sliderMessage = document.getElementById('slider-message');
        const limitWarning = document.getElementById('limit-warning');
        const limitWarningText = document.getElementById('limit-warning-text');

        // State
        let diffWorker = null;
        let currentResults = [];
        let currentStats = null;
        let currentChangeIndex = -1;
        // Mode toggles - all three ON by default
        let modeToggles = {
            lines: true,
            words: true,
            chars: true
        };
        let currentView = 'split';
        let detectedLanguage = null; // Store detected language for syntax highlighting
        
        // Constants
        const LIMITS = {
            MAX_FILE_SIZE: 5 * 1024 * 1024,  // 5MB
            WARNING_THRESHOLD: 50000,         // 50k lines
            MEMORY_WARNING: 100 * 1024        // 100KB
        };

        // Default Configuration
        const DEFAULT_CONFIG = {
            maxLines: 50000,
            maxGraphVertices: 100000,
            maxBytes: 5000000,
            astLineThreshold: 1000,
            enableAST: true,
            enableGraphDiff: false,
            enableFastMode: true,
            normalizeDelimiters: false,
            correctSliders: false
        };

        // Current configuration (loaded from localStorage or defaults)
        let currentConfig = { ...DEFAULT_CONFIG };

        // Config localStorage key
        const CONFIG_STORAGE_KEY = 'textDiffTool_config';

        /**
         * Toggle the configuration panel visibility
         */
        window.toggleConfigPanel = function() {
            const isHidden = configPanel.classList.contains('hidden');
            if (isHidden) {
                configPanel.classList.remove('hidden');
                configPanel.removeAttribute('aria-hidden');
                configToggleBtn.setAttribute('aria-expanded', 'true');
                // Focus the first input for accessibility
                setTimeout(() => maxVerticesInput.focus(), 100);
            } else {
                configPanel.classList.add('hidden');
                configPanel.setAttribute('aria-hidden', 'true');
                configToggleBtn.setAttribute('aria-expanded', 'false');
                // Return focus to the toggle button
                configToggleBtn.focus();
            }
        };

        /**
         * Load configuration from localStorage
         * Falls back to defaults if not found or invalid
         */
        function loadConfig() {
            try {
                const savedConfig = localStorage.getItem(CONFIG_STORAGE_KEY);
                if (savedConfig) {
                    const parsed = JSON.parse(savedConfig);
                    // Merge with defaults to ensure all keys exist
                    currentConfig = {
                        ...DEFAULT_CONFIG,
                        ...parsed
                    };
                    console.log('Configuration loaded from localStorage');
                }
            } catch (error) {
                console.warn('Failed to load config from localStorage:', error);
                currentConfig = { ...DEFAULT_CONFIG };
            }
            
            // Apply loaded config to UI
            applyConfigToUI();
        }

        /**
         * Save configuration to localStorage
         */
        window.saveConfig = function() {
            // Read values from inputs
            currentConfig = {
                maxLines: parseInt(maxLinesInput.value, 10) || DEFAULT_CONFIG.maxLines,
                maxGraphVertices: parseInt(maxVerticesInput.value, 10) || DEFAULT_CONFIG.maxGraphVertices,
                maxBytes: parseInt(maxBytesInput.value, 10) || DEFAULT_CONFIG.maxBytes,
                enableAST: enableAstCheckbox.checked,
                enableGraphDiff: enableGraphDiffCheckbox.checked,
                enableFastMode: enableFastModeCheckbox.checked,
                normalizeDelimiters: normalizeDelimitersCheckbox.checked,
                correctSliders: correctSlidersCheckbox.checked
            };

            // Validate values
            currentConfig.maxLines = Math.max(1000, Math.min(200000, currentConfig.maxLines));
            currentConfig.maxGraphVertices = Math.max(1000, Math.min(1000000, currentConfig.maxGraphVertices));
            currentConfig.maxBytes = Math.max(100000, Math.min(10000000, currentConfig.maxBytes));
            currentConfig.astLineThreshold = Math.max(100, Math.min(10000, currentConfig.astLineThreshold));

            try {
                localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(currentConfig));
                console.log('Configuration saved to localStorage');
                
                // Show feedback
                const originalText = event.target.textContent;
                event.target.textContent = 'Saved!';
                event.target.disabled = true;
                
                setTimeout(() => {
                    event.target.textContent = originalText;
                    event.target.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Failed to save config:', error);
                handleError('Settings', 'Failed to save settings. Please try again.', { error });
            }
        };

        /**
         * Reset configuration to defaults
         */
        window.resetConfig = function() {
            currentConfig = { ...DEFAULT_CONFIG };
            applyConfigToUI();
            
            // Save defaults to localStorage
            try {
                localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(currentConfig));
                console.log('Configuration reset to defaults');
                
                // Show feedback
                const resetBtn = event.target;
                const originalText = resetBtn.textContent;
                resetBtn.textContent = 'Reset!';
                resetBtn.disabled = true;
                
                setTimeout(() => {
                    resetBtn.textContent = originalText;
                    resetBtn.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Failed to reset config:', error);
            }
        };

        /**
         * Apply current configuration values to UI inputs
         */
        function applyConfigToUI() {
            maxLinesInput.value = currentConfig.maxLines;
            maxVerticesInput.value = currentConfig.maxGraphVertices;
            maxBytesInput.value = currentConfig.maxBytes;
            astThresholdInput.value = currentConfig.astLineThreshold;
            enableAstCheckbox.checked = currentConfig.enableAST;
            enableGraphDiffCheckbox.checked = currentConfig.enableGraphDiff;
            enableFastModeCheckbox.checked = currentConfig.enableFastMode;
            normalizeDelimitersCheckbox.checked = currentConfig.normalizeDelimiters;
            correctSlidersCheckbox.checked = currentConfig.correctSliders;
        }

        /**
         * Get current configuration object
         * @returns {Object} Current configuration
         */
        function getConfig() {
            return { ...currentConfig };
        }
        
        // Version management
        const VERSION = {
            current: "0.1.14",
            previous: localStorage.getItem("textDiffTool_version") || "0.0.0",
            update: function(newVersion) {
                this.previous = this.current;
                this.current = newVersion;
                this.save();
                this.display();
            },
            save: function() {
                localStorage.setItem("textDiffTool_version", this.current);
            },
            display: function() {
                const versionElement = document.getElementById("version-info");
                if (versionElement) {
                    versionElement.textContent = `Version ${this.current}`;
                }
            }
        };
        
        // Initialize worker
        function initWorker() {
            console.log('[Main] initWorker called');
            if (!diffWorker) {
                console.log('[Main] Creating new DiffWorker...');
                diffWorker = new DiffWorker(WORKER_CODE_TEMPLATE);
                console.log('[Main] DiffWorker created');
                
                // Expose validation functions globally for debugging
                window.ModuleValidator = {
                    validateWorkerModule,
                    getBrowserCompatibility: async () => {
                        // Import function locally
                        const validatorModule = await import('./src/module-validator.js?v=9');
                        return validatorModule.getBrowserCompatibility();
                    },
                    getWorkerHealthStatus: () => diffWorker.getHealthStatus(),
                    getValidationResult: () => diffWorker.getValidationResult()
                };
            }
        }
        
        // Show progress modal
        function showProgressModal() {
            progressModal.classList.remove('hidden');
            const startTime = Date.now();
            
            return {
                close: () => {
                    const elapsed = Date.now() - startTime;
                    const remaining = Math.max(0, 1000 - elapsed); // Minimum 1 second display
                    setTimeout(() => {
                        progressModal.classList.add('hidden');
                    }, remaining);
                }
            };
        }
        
        // Update stats display
        function updateStats(stats) {
            statAdded.textContent = stats.added || 0;
            statRemoved.textContent = stats.removed || 0;
            statModified.textContent = stats.modified || 0;
            statMoved.textContent = stats.moved || 0;
        }
        
        // Show complexity limit warning
        function showLimitWarning(limitInfo) {
            let message = '';
            
            if (limitInfo.reason === 'line_count') {
                message = `Fast mode active: File exceeds ${limitInfo.maxLines.toLocaleString()} line limit (${limitInfo.lineCount.toLocaleString()} lines). Using simplified comparison.`;
            } else if (limitInfo.reason === 'graph_size') {
                message = `Fast mode active: Too many changes (${limitInfo.removedCount.toLocaleString()} removed × ${limitInfo.addedCount.toLocaleString()} added = ${limitInfo.graphSize.toLocaleString()} graph vertices, limit: ${limitInfo.maxGraphVertices.toLocaleString()}). Using simplified comparison.`;
            } else {
                message = 'Fast mode active: Complexity limits exceeded. Using simplified comparison.';
            }
            
            limitWarningText.textContent = message;
            limitWarning.classList.remove('hidden');
        }
        
        /**
         * Determine if a change is "small" enough for character-level highlighting
         * vs "large" enough for word-level highlighting
         * 
         * Criteria: Use char mode if:
         * - ≤ 20% of line changed AND ≤ 10 characters changed, OR
         * - ≤ 3 characters changed (absolute, for very small changes)
         * 
         * @param {Array} diffParts - The diff parts array from diffChars or diffWords
         * @param {string} originalLine - The original line text
         * @returns {boolean} - True if char highlighting should be used
         */
        function shouldUseCharHighlighting(diffParts, originalLine) {
            if (!diffParts || diffParts.length === 0) return false;
            
            let changedChars = 0;
            let totalChars = originalLine.length;
            
            diffParts.forEach(part => {
                if (part.added || part.removed) {
                    changedChars += part.value.length;
                }
            });
            
            // Small change criteria:
            // 1. Absolute: ≤ 3 characters changed
            // 2. Percentage: ≤ 20% changed (for longer lines)
            const isSmallAbsolute = changedChars <= 3;
            const isSmallPercentage = totalChars > 0 && (changedChars / totalChars) <= 0.20;
            
            return isSmallAbsolute || (isSmallPercentage && changedChars <= 10);
        }

        /**
         * Get the appropriate diff parts based on change size and enabled modes
         * Uses hybrid selection: char for small changes, word for larger changes
         * 
         * @param {Object} change - The change object containing wordDiff and charDiff
         * @param {string} removedLine - The removed line text
         * @param {string} addedLine - The added line text
         * @returns {Object} - { parts: Array, isCharMode: boolean }
         */
        function getDiffPartsForChange(change, removedLine, addedLine) {
            // Check if char mode is enabled and available
            if (modeToggles.chars && change.charDiff) {
                const isSmallChange = shouldUseCharHighlighting(change.charDiff, removedLine);
                if (isSmallChange) {
                    return { parts: change.charDiff, isCharMode: true };
                }
            }
            
            // Fall back to word mode if available
            if (modeToggles.words && change.wordDiff) {
                return { parts: change.wordDiff, isCharMode: false };
            }
            
            // No inline diff available
            return { parts: null, isCharMode: false };
        }

        /**
         * Split diff parts by line boundaries for multi-line rendering
         * When diffLines groups consecutive changed lines, this splits the wordDiff/charDiff
         * into per-line parts for proper inline highlighting
         * 
         * @param {Array} diffParts - The full diff parts array (wordDiff or charDiff)
         * @param {Array} lineTexts - Array of line texts to determine boundaries
         * @returns {Array} - Array of diff parts arrays, one per line
         */
        function splitDiffPartsByLines(diffParts, lineTexts) {
            if (!diffParts || diffParts.length === 0) {
                return lineTexts.map(line => [{ value: line, added: false, removed: false }]);
            }
            
            const result = [];
            let currentLineIdx = 0;
            let currentLineParts = [];
            let currentLineText = lineTexts[0] || '';
            let position = 0;
            
            for (const part of diffParts) {
                const partLines = part.value.split('\n');
                
                if (partLines.length === 1) {
                    // Part doesn't contain newline - add to current line
                    currentLineParts.push(part);
                    position += part.value.length;
                } else {
                    // Part spans multiple lines - split it up
                    for (let i = 0; i < partLines.length; i++) {
                        const linePart = partLines[i];
                        if (linePart !== '' || i < partLines.length - 1) {
                            // Add this portion to current line
                            currentLineParts.push({
                                value: linePart,
                                added: part.added,
                                removed: part.removed
                            });
                            
                            // If not the last part, this line is complete
                            if (i < partLines.length - 1) {
                                result.push(currentLineParts);
                                currentLineIdx++;
                                currentLineParts = [];
                                currentLineText = lineTexts[currentLineIdx] || '';
                                position = 0;
                            }
                        }
                    }
                }
            }
            
            // Push the last line's parts
            if (currentLineParts.length > 0) {
                result.push(currentLineParts);
            }
            
            // Ensure we have parts for all lines
            while (result.length < lineTexts.length) {
                const lineIdx = result.length;
                result.push([{ value: lineTexts[lineIdx] || '', added: false, removed: false }]);
            }
            
            return result;
        }

        // Performance state for syntax highlighting
        let syntaxHighlightingEnabled = true;
        const SYNTAX_HIGHLIGHTING_MAX_LINES = 1000; // Disable syntax highlighting beyond this limit
        let totalUnchangedLines = 0;
        
        // Tree-sitter state
        let treeSitterParser = null;
        let treeSitterLanguage = null;
        let highlightQuery = null;
        let treeSitterReady = false;
        let treeSitterError = false;

        /**
         * Initialize Tree-sitter for syntax highlighting
         * @param {string} language - Language to initialize
         */
        async function initTreeSitterHighlighting(language) {
            // Don't re-initialize if already ready or if we had an error
            if (treeSitterReady || treeSitterError) {
                return treeSitterReady;
            }
            
            // Only initialize if we have a supported language
            if (!language || !['javascript', 'typescript', 'python', 'json', 'html', 'css', 'go', 'rust', 'java', 'c', 'cpp', 'yaml', 'bash'].includes(language)) {
                treeSitterError = true;
                return false;
            }
            
            try {
                // Import tree-sitter modules
                const baseUrl = window.location.origin;
                const { initTreeSitter, getLanguageParser } = await import(`${baseUrl}/src/tree-sitter-loader.js?v=13`);
                const { createHighlightQuery } = await import(`${baseUrl}/src/highlight-query.js?v=13`);
                
                // Initialize Tree-sitter
                await initTreeSitter();
                
                // Get language parser
                treeSitterParser = await getLanguageParser(language);
                treeSitterLanguage = language;
                
                // Create highlight query
                highlightQuery = await createHighlightQuery(language);
                
                treeSitterReady = true;
                console.log(`[SyntaxHighlight] Tree-sitter initialized for ${language}`);
                return true;
            } catch (error) {
                console.warn('[SyntaxHighlight] Tree-sitter initialization failed:', error);
                treeSitterError = true;
                return false;
            }
        }

        /**
         * Prepare AST features for diff comparison
         * Parses both files with Tree-sitter and extracts serializable AST features
         * to pass to the Web Worker for AST-aware similarity calculation
         * 
         * @param {string} oldText - Previous version text
         * @param {string} newText - Current version text
         * @param {string} language - Detected programming language
         * @returns {Promise<Object|null>} AST features for both files or null if unavailable
         */
        async function prepareDiffWithAST(oldText, newText, language) {
            // Skip if no language detected or language not supported
            if (!language || !['javascript', 'typescript', 'python', 'json', 'html', 'css', 'go', 'rust', 'java', 'c', 'cpp', 'yaml', 'bash'].includes(language)) {
                return null;
            }
            
            // Skip if files are too large (AST parsing is expensive)
            const totalLines = Math.max(
                oldText.split('\n').length,
                newText.split('\n').length
            );
            if (totalLines > 1000) {
                console.log('[AST] Skipping AST features for large files (>1000 lines)');
                return null;
            }
            
            try {
                // Ensure Tree-sitter is initialized (reuses existing initialization)
                const initialized = await initTreeSitterHighlighting(language);
                if (!initialized || !treeSitterParser) {
                    return null;
                }
                
                // Import the feature extractor
                const baseUrl = window.location.origin;
                const { prepareASTFeatures } = await import(`${baseUrl}/src/ast-feature-extractor.js?v=9`);
                
                // Extract features for both files
                console.log('[AST] Extracting AST features for diff comparison...');
                const astFeatures = prepareASTFeatures(treeSitterParser, oldText, newText);
                
                if (astFeatures) {
                    console.log('[AST] AST features prepared successfully');
                }
                
                return astFeatures;
            } catch (error) {
                console.warn('[AST] Failed to prepare AST features:', error.message);
                return null;
            }
        }

        /**
         * Tokenize and render unchanged lines with syntax highlighting
         * Uses Tree-sitter for accurate syntax highlighting when available,
         * falls back to lightweight tokenizer for unsupported languages
         * 
         * @param {string} line - The line to tokenize and highlight
         * @param {string} language - Detected language type
         * @returns {DocumentFragment} - The rendered fragment with syntax highlighting
         */
        async function renderUnchangedLine(line, language) {
            const fragment = document.createDocumentFragment();
            
            // Disable syntax highlighting if performance limit exceeded
            if (!syntaxHighlightingEnabled) {
                fragment.textContent = line;
                return fragment;
            }
            
            // Try Tree-sitter first if available
            if (treeSitterReady && language === treeSitterLanguage) {
                try {
                    const highlighted = await renderLineWithTreeSitter(line);
                    if (highlighted) {
                        fragment.appendChild(highlighted);
                        totalUnchangedLines++;
                        return fragment;
                    }
                } catch (error) {
                    console.warn('[SyntaxHighlight] Tree-sitter highlighting failed, falling back:', error);
                }
            }
            
            // Initialize Tree-sitter for supported languages
            if (!treeSitterError && !treeSitterReady && language) {
                // Don't await - initialize in background
                initTreeSitterHighlighting(language);
            }
            
            // Fallback to simple tokenizer
            try {
                const tokens = tokenizeLineSync(line);
                
                tokens.forEach(token => {
                    const span = document.createElement('span');
                    span.textContent = token.value;
                    
                    // Apply CSS class based on token type
                    switch (token.type) {
                        case 'keyword':
                            span.className = 'syntax-keyword';
                            break;
                        case 'string':
                            span.className = 'syntax-string';
                            break;
                        case 'number':
                            span.className = 'syntax-number';
                            break;
                        case 'comment':
                            span.className = 'syntax-comment';
                            break;
                        case 'identifier':
                            span.className = 'syntax-identifier';
                            break;
                        case 'operator':
                            span.className = 'syntax-operator';
                            break;
                        case 'delimiter':
                            span.className = 'syntax-delimiter';
                            break;
                        case 'whitespace':
                            // Whitespace gets no special styling
                            break;
                        default:
                            span.className = 'syntax-other';
                            break;
                    }
                    
                    fragment.appendChild(span);
                });
            } catch (error) {
                // Fallback to plain text if tokenization fails
                console.warn('Syntax highlighting failed, using plain text:', error);
                fragment.textContent = line;
            }
            
            // Track total unchanged lines for performance management
            totalUnchangedLines++;
            return fragment;
        }

        /**
         * Render a line using Tree-sitter syntax highlighting
         * @param {string} line - Line to highlight
         * @returns {Promise<DocumentFragment|null>} - Highlighted fragment or null if failed
         */
        async function renderLineWithTreeSitter(line) {
            if (!treeSitterParser || !highlightQuery) {
                return null;
            }
            
            try {
                // Parse the line (add newline for proper parsing)
                const tree = treeSitterParser.parse(line + '\n');
                const rootNode = tree.rootNode;
                
                const fragment = document.createDocumentFragment();
                let lastEnd = 0;
                
                // Get highlights from the query
                const captures = highlightQuery.captures(rootNode);
                
                // Sort captures by start position
                captures.sort((a, b) => a.node.startIndex - b.node.startIndex);
                
                // Render text with syntax highlighting
                for (const capture of captures) {
                    const node = capture.node;
                    const start = node.startIndex;
                    const end = node.endIndex;
                    
                    // Add text before this highlight
                    if (start > lastEnd) {
                        const textSpan = document.createElement('span');
                        textSpan.textContent = line.slice(lastEnd, start);
                        fragment.appendChild(textSpan);
                    }
                    
                    // Add highlighted text
                    const highlightSpan = document.createElement('span');
                    highlightSpan.textContent = line.slice(start, end);
                    highlightSpan.className = `syntax-${capture.name}`;
                    fragment.appendChild(highlightSpan);
                    
                    lastEnd = end;
                }
                
                // Add remaining text
                if (lastEnd < line.length) {
                    const textSpan = document.createElement('span');
                    textSpan.textContent = line.slice(lastEnd);
                    fragment.appendChild(textSpan);
                }
                
                return fragment;
            } catch (error) {
                console.warn('[SyntaxHighlight] Tree-sitter rendering failed for line:', error);
                return null;
            }
        }

        /**
         * Simple synchronous tokenizer for syntax highlighting
         * Lightweight version of the tokenizer module for immediate rendering
         * 
         * @param {string} line - Line to tokenize
         * @returns {Array} - Array of token objects
         */
        function tokenizeLineSync(line) {
            const tokens = [];
            let i = 0;
            
            // Common keywords across languages
            const keywords = new Set([
                'const', 'let', 'var', 'function', 'class', 'if', 'else', 'for', 'while',
                'return', 'try', 'catch', 'new', 'this', 'import', 'export', 'async', 'await',
                'def', 'class', 'if', 'elif', 'else', 'for', 'while', 'return', 'import',
                'public', 'private', 'static', 'final', 'int', 'float', 'bool', 'void',
                'SELECT', 'FROM', 'WHERE', 'INSERT', 'UPDATE', 'DELETE', 'AND', 'OR'
            ]);
            
            // Operators
            const operators = new Set([
                '===', '!==', '==', '!=', '<=', '>=', '=>', '->', '**', '//', '++', '--',
                '&&', '||', '<<', '>>', '::', '??', '?.', '...', '..',
                '+', '-', '*', '/', '%', '=', '<', '>', '!', '~', '&', '|', '^', '?', ':'
            ]);
            
            // Delimiters
            const delimiters = new Set(['(', ')', '[', ']', '{', '}', ',', ';', '.']);
            
            while (i < line.length) {
                const char = line[i];
                
                // Handle whitespace
                if (/\s/.test(char)) {
                    let value = '';
                    while (i < line.length && /\s/.test(line[i])) {
                        value += line[i];
                        i++;
                    }
                    tokens.push({ type: 'whitespace', value });
                    continue;
                }
                
                // Handle comments
                if ((char === '/' && line[i + 1] === '/') || 
                    char === '#' || 
                    (char === '-' && line[i + 1] === '-')) {
                    const value = line.substring(i);
                    tokens.push({ type: 'comment', value });
                    break;
                }
                
                // Handle string literals
                if (char === '"' || char === "'" || char === '`') {
                    const quote = char;
                    let value = char;
                    i++;
                    while (i < line.length) {
                        if (line[i] === '\\') {
                            value += line[i];
                            i++;
                            if (i < line.length) {
                                value += line[i];
                                i++;
                            }
                        } else if (line[i] === quote) {
                            value += line[i];
                            i++;
                            break;
                        } else {
                            value += line[i];
                            i++;
                        }
                    }
                    tokens.push({ type: 'string', value });
                    continue;
                }
                
                // Handle numbers
                if (/\d/.test(char) || (char === '.' && /\d/.test(line[i + 1]))) {
                    let value = '';
                    while (i < line.length && (/\d/.test(line[i]) || line[i] === '.' || 
                           line[i] === 'e' || line[i] === 'E' || line[i] === 'x' ||
                           line[i] === 'X' || line[i] === 'b' || line[i] === 'B')) {
                        value += line[i];
                        i++;
                    }
                    tokens.push({ type: 'number', value });
                    continue;
                }
                
                // Handle multi-character operators
                let matchedOperator = false;
                for (const op of [...operators].sort((a, b) => b.length - a.length)) {
                    if (line.substring(i, i + op.length) === op) {
                        tokens.push({ type: 'operator', value: op });
                        i += op.length;
                        matchedOperator = true;
                        break;
                    }
                }
                if (matchedOperator) continue;
                
                // Handle delimiters
                if (delimiters.has(char)) {
                    tokens.push({ type: 'delimiter', value: char });
                    i++;
                    continue;
                }
                
                // Handle identifiers and keywords
                if (/[a-zA-Z_$]/.test(char)) {
                    let value = '';
                    while (i < line.length && /[a-zA-Z0-9_$]/.test(line[i])) {
                        value += line[i];
                        i++;
                    }
                    const type = keywords.has(value) ? 'keyword' : 'identifier';
                    tokens.push({ type, value });
                    continue;
                }
                
                // Unknown character
                tokens.push({ type: 'other', value: char });
                i++;
            }
            
            return tokens;
        }

/**
         * Render inline diff for modified lines with hierarchical highlighting
         * Supports multiple simultaneous modes: char, word, and line level
         * CSS precedence ensures proper visual hierarchy (char darkest > word medium > line lightest)
         * 
         * @param {Array} diffParts - The diff parts to render
         * @param {string} panel - 'previous' shows removed parts in red, 'current' shows added parts in green
         * @param {boolean} isCharMode - Whether this is character-level highlighting
         * @param {Object} change - The full change object containing nestedDiffs (optional)
         * @returns {DocumentFragment} - The rendered fragment
         */
        function renderInlineDiff(diffParts, panel = 'previous', isCharMode = false, change = null) {
            const fragment = document.createDocumentFragment();
            
            if (!diffParts || diffParts.length === 0) {
                return fragment;
            }

            // If we have nested diffs, use them for comment/string regions
            if (change && change.nestedDiffs && change.nestedDiffs.length > 0 && modeToggles.words) {
                return renderInlineDiffWithNested(diffParts, panel, isCharMode, change);
            }

            // Standard rendering without nested diffs
            diffParts.forEach(part => {
                const span = document.createElement('span');
                span.textContent = part.value;

                if (panel === 'previous') {
                    // In previous panel: show removed parts highlighted, unchanged parts normal
                    // Don't show added parts (they don't exist in old version)
                    if (part.removed) {
                        // Apply all enabled highlight classes simultaneously
                        // CSS specificity will handle visual hierarchy
                        const classes = [];
                        if (modeToggles.chars && isCharMode) {
                            classes.push('inline-removed-char');
                        }
                        // Line-level is always applied as base
                        if (modeToggles.lines) {
                            classes.push('inline-removed-line');
                        }
                        span.className = classes.join(' ') || 'inline-removed-line';
                    } else if (part.added) {
                        // Skip added parts in previous panel - they don't exist in old version
                        return;
                    } else {
                        span.className = 'inline-unchanged';
                    }
                } else {
                    // In current panel: show added parts highlighted, unchanged parts normal
                    // Don't show removed parts (they don't exist in new version)
                    if (part.added) {
                        // Apply all enabled highlight classes simultaneously
                        // CSS specificity will handle visual hierarchy
                        const classes = [];
                        if (modeToggles.chars && isCharMode) {
                            classes.push('inline-added-char');
                        }
                        if (modeToggles.words && !isCharMode) {
                            classes.push('inline-added-word');
                        }
                        // Line-level is always applied as base
                        if (modeToggles.lines) {
                            classes.push('inline-added-line');
                        }
                        span.className = classes.join(' ') || 'inline-added-line';
                    } else if (part.removed) {
                        // Skip removed parts in current panel - they don't exist in new version
                        return;
                    } else {
                        span.className = 'inline-unchanged';
                    }
                }

                fragment.appendChild(span);
            });

            return fragment;
        }

        /**
         * Render inline diff with nested highlighting for comment/string regions
         * Uses word-level diff inside comments/strings, char-level diff for code regions
         * 
         * @param {Array} diffParts - The diff parts to render
         * @param {string} panel - 'previous' or 'current'
         * @param {boolean} isCharMode - Whether this is character-level highlighting
         * @param {Object} change - The change object with nestedDiffs
         * @returns {DocumentFragment} - The rendered fragment
         */
        function renderInlineDiffWithNested(diffParts, panel, isCharMode, change) {
            const fragment = document.createDocumentFragment();
            const lineText = panel === 'previous' ? change.removedLine : change.addedLine;
            let position = 0;

            // Process all diff parts and apply nested highlighting where applicable
            diffParts.forEach(part => {
                const partStart = position;
                const partEnd = position + part.value.length;
                
                // Check if this part intersects with any nested regions
                const intersectingNested = change.nestedDiffs.filter(nested => {
                    const region = panel === 'previous' ? nested.removedRegion : nested.addedRegion;
                    return region && region.start < partEnd && region.end > partStart;
                });

                if (intersectingNested.length === 0) {
                    // No nested diffs, render normally
                    const span = document.createElement('span');
                    span.textContent = part.value;
                    
                    if (panel === 'previous' && part.removed) {
                        span.className = 'inline-removed-line';
                    } else if (panel === 'current' && part.added) {
                        span.className = 'inline-added-line';
                    } else {
                        span.className = 'inline-unchanged';
                    }
                    
                    fragment.appendChild(span);
                } else {
                    // This part intersects with nested diffs, need special handling
                    renderPartWithNestedDiffs(fragment, part, panel, intersectingNested, partStart);
                }
                
                position = partEnd;
            });

            return fragment;
        }

        /**
         * Render a diff part with nested diffs applied
         * 
         * @param {DocumentFragment} fragment - Fragment to append to
         * @param {Object} part - The diff part
         * @param {string} panel - 'previous' or 'current'
         * @param {Array} nestedDiffs - Nested diffs that intersect this part
         * @param {number} partStart - Start position of this part in the line
         */
        function renderPartWithNestedDiffs(fragment, part, panel, nestedDiffs, partStart) {
            let position = 0;
            const nestedRegions = nestedDiffs.map(n => 
                panel === 'previous' ? n.removedRegion : n.addedRegion
            ).filter(r => r);

            // Sort nested regions by start position
            nestedRegions.sort((a, b) => a.start - b.start);

            for (const nested of nestedRegions) {
                // Render content before nested region
                if (position < nested.start - partStart) {
                    const beforeText = part.value.substring(position, nested.start - partStart);
                    const span = document.createElement('span');
                    span.textContent = beforeText;
                    
                    if (panel === 'previous' && part.removed) {
                        span.className = 'inline-removed-line';
                    } else if (panel === 'current' && part.added) {
                        span.className = 'inline-added-line';
                    } else {
                        span.className = 'inline-unchanged';
                    }
                    
                    fragment.appendChild(span);
                }

                // Render nested region with word-level diff
                const nestedDiff = nestedDiffs.find(n => {
                    const region = panel === 'previous' ? n.removedRegion : n.addedRegion;
                    return region && region.start === nested.start && region.end === nested.end;
                });

                if (nestedDiff && nestedDiff.wordDiff) {
                    const nestedFragment = document.createDocumentFragment();
                    nestedDiff.wordDiff.forEach(nestedPart => {
                        const span = document.createElement('span');
                        span.textContent = nestedPart.value;
                        
                        if (panel === 'previous' && nestedPart.removed) {
                            span.className = 'inline-removed-word nested'; // Nested word diff in comment/string
                        } else if (panel === 'current' && nestedPart.added) {
                            span.className = 'inline-added-word nested'; // Nested word diff in comment/string
                        } else {
                            span.className = 'inline-unchanged';
                        }
                        
                        nestedFragment.appendChild(span);
                    });
                    fragment.appendChild(nestedFragment);
                } else {
                    // No word diff available, render as regular highlighted
                    const nestedText = part.value.substring(
                        nested.start - partStart, 
                        nested.end - partStart
                    );
                    const span = document.createElement('span');
                    span.textContent = nestedText;
                    
                    if (panel === 'previous' && part.removed) {
                        span.className = 'inline-removed-line';
                    } else if (panel === 'current' && part.added) {
                        span.className = 'inline-added-line';
                    } else {
                        span.className = 'inline-unchanged';
                    }
                    
                    fragment.appendChild(span);
                }

                position = nested.end - partStart;
            }

            // Render any remaining content after last nested region
            if (position < part.value.length) {
                const afterText = part.value.substring(position);
                const span = document.createElement('span');
                span.textContent = afterText;
                
                if (panel === 'previous' && part.removed) {
                    span.className = 'inline-removed-line';
                } else if (panel === 'current' && part.added) {
                    span.className = 'inline-added-line';
                } else {
                    span.className = 'inline-unchanged';
                }
                
                fragment.appendChild(span);
            }
        }

        // Render unified diff view
        async function renderUnifiedDiff(results, stats) {
            // Reset performance counters
            totalUnchangedLines = 0;
            syntaxHighlightingEnabled = true;
            
            // Check if we should disable syntax highlighting for performance
            const unchangedLineCount = results.filter(r => 
                (r.classification || (r.added ? 'added' : r.removed ? 'removed' : 'unchanged')) === 'unchanged'
            ).length;
            
            if (unchangedLineCount > SYNTAX_HIGHLIGHTING_MAX_LINES) {
                syntaxHighlightingEnabled = false;
                console.log(`Disabling syntax highlighting: ${unchangedLineCount} unchanged lines exceeds limit of ${SYNTAX_HIGHLIGHTING_MAX_LINES}`);
            }
            
            unifiedDiffContent.innerHTML = '';
            
            const fragment = document.createDocumentFragment();
            let prevLineNum = 1;
            let currLineNum = 1;
            
            for (const [index, change] of results.entries()) {
                const classification = change.classification || (change.added ? 'added' : change.removed ? 'removed' : 'unchanged');

                // Skip the "added" side of a modified pair - we render both old and new when processing the "removed" side
                if (classification === 'modified' && change.added) {
                    continue;
                }

                if (classification === 'unchanged') {
                    // Split unchanged lines in case the diff library grouped them
                    const lines = change.value.split('\n');
                    // Keep all lines except the trailing empty string (from split on trailing newline)
                    const validLines = lines.filter((line, idx) => !(line === '' && idx === lines.length - 1));

                    // Process unchanged lines sequentially to handle async highlighting
                    for (let i = 0; i < validLines.length; i++) {
                        const line = validLines[i];
                        
                        // Show each unchanged line with its own line number pair
                        const row = document.createElement('div');
                        row.className = 'unified-row';
                        row.dataset.index = index;
                        row.dataset.testid = 'unified-row';
                        
                        const marker = document.createElement('div');
                        marker.className = 'unified-marker';
                        marker.textContent = ' ';
                        
                        // Show both line numbers separated by a colon
                        const lineNumDiv = document.createElement('div');
                        lineNumDiv.className = 'unified-line-num';
                        lineNumDiv.textContent = `${prevLineNum}:${currLineNum}`;
                        lineNumDiv.style.fontSize = '11px';
                        lineNumDiv.style.letterSpacing = '-0.5px';
                        
                        const content = document.createElement('div');
                        content.className = 'unified-content';
                        
                        // Apply syntax highlighting to unchanged lines
                        const highlightedContent = await renderUnchangedLine(' ' + line, detectedLanguage);
                        content.appendChild(highlightedContent);

                        row.appendChild(marker);
                        row.appendChild(lineNumDiv);
                        row.appendChild(content);
                        fragment.appendChild(row);
                        
                        prevLineNum++;
                        currLineNum++;
                    }
                } else if (classification === 'removed') {
                    // Show removed lines - split into individual lines if grouped
                    // Check if this is actually a block move source
                    const blockInfo = change.blockMoveInfo;
                    const isBlockMove = classification === 'block-moved' || (blockInfo && (change.blockMoveSource !== undefined || change.blockMoveDestination !== undefined));
                    const isModified = blockInfo && blockInfo.similarity !== undefined && blockInfo.similarity < 0.99;
                    
                    const removedLines = change.value.split('\n');
                    const validRemovedLines = removedLines.filter((line, idx) => !(line === '' && idx === removedLines.length - 1));

                    validRemovedLines.forEach((line) => {
                        const row = document.createElement('div');
                        row.dataset.testid = 'unified-row';
                        const marker = document.createElement('div');
                        marker.className = 'unified-marker';
                        
                        if (isBlockMove) {
                            // Block move source: use '<' for pure, '≤' for modified
                            const symbol = isModified ? '≤' : '<';
                            const cssClass = isModified ? 'block-moved-from-modified' : 'block-moved-from';
                            const tooltipText = isModified 
                                ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                                : `Block moved to line ${blockInfo.to + 1}`;
                            
                            row.className = `unified-row ${cssClass} block-moved-source block-moved-indicator`;
                            marker.textContent = symbol;
                            row.title = tooltipText;
                        } else {
                            // Regular removal
                            row.className = 'unified-row removed';
                            marker.textContent = '-';
                        }
                        
                        row.dataset.index = index;

                        const lineNumDiv = document.createElement('div');
                        lineNumDiv.className = 'unified-line-num';
                        lineNumDiv.textContent = prevLineNum;

                        const content = document.createElement('div');
                        content.className = 'unified-content';
                        content.textContent = line;

                        row.appendChild(marker);
                        row.appendChild(lineNumDiv);
                        row.appendChild(content);
                        fragment.appendChild(row);

                        prevLineNum++;
                    });
                } else if (classification === 'added') {
                    // Show added lines - split into individual lines if grouped
                    // Check if this is actually a block move destination
                    const blockInfo = change.blockMoveInfo;
                    const isBlockMove = classification === 'block-moved' || (blockInfo && (change.blockMoveSource !== undefined || change.blockMoveDestination !== undefined));
                    const isModified = blockInfo && blockInfo.similarity !== undefined && blockInfo.similarity < 0.99;
                    
                    const addedLines = change.value.split('\n');
                    const validAddedLines = addedLines.filter((line, idx) => !(line === '' && idx === addedLines.length - 1));

                    validAddedLines.forEach((line) => {
                        const row = document.createElement('div');
                        row.dataset.testid = 'unified-row';
                        const marker = document.createElement('div');
                        marker.className = 'unified-marker';
                        
                        if (isBlockMove) {
                            // Block move destination: use '>' for pure, '≥' for modified
                            const symbol = isModified ? '≥' : '>';
                            const cssClass = isModified ? 'block-moved-to-modified' : 'block-moved-to';
                            const tooltipText = isModified
                                ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                                : `Block moved from line ${blockInfo.from + 1}`;
                            
                            row.className = `unified-row ${cssClass} block-moved-destination block-moved-indicator`;
                            marker.textContent = symbol;
                            row.title = tooltipText;
                        } else {
                            // Regular addition
                            row.className = 'unified-row added';
                            marker.textContent = '+';
                        }
                        
                        row.dataset.index = index;

                        const lineNumDiv = document.createElement('div');
                        lineNumDiv.className = 'unified-line-num';
                        lineNumDiv.textContent = currLineNum;
                        
                        const content = document.createElement('div');
                        content.className = 'unified-content';
                        content.textContent = line;
                        
                        row.appendChild(marker);
                        row.appendChild(lineNumDiv);
                        row.appendChild(content);
                        fragment.appendChild(row);

                        currLineNum++;
                    });
                } else if (classification === 'modified') {
                    // Show both old and new versions for modified lines
                    // Use the stored removedLine and addedLine values from the classified result
                    const removedLineValue = change.removedLine || change.value;
                    const addedLineValue = change.addedLine || change.value;
                    
                    // Check if modified content spans multiple lines
                    const modLines = removedLineValue.split('\n');
                    const validModLines = modLines.filter((line, idx) => !(line === '' && idx === modLines.length - 1));
                    const addedLines = addedLineValue.split('\n');
                    const validAddedLines = addedLines.filter((line, idx) => !(line === '' && idx === addedLines.length - 1));
                    
                    // Split the diff parts by lines for proper per-line highlighting
                    const diffParts = getDiffPartsForChange(change, removedLineValue, addedLineValue);
                    let oldLineParts = [];
                    let newLineParts = [];
                    
                    if (diffParts.parts && (modeToggles.words || modeToggles.chars)) {
                        oldLineParts = splitDiffPartsByLines(diffParts.parts, validModLines);
                        newLineParts = splitDiffPartsByLines(diffParts.parts, validAddedLines);
                    }
                    
                    const lineCount = Math.max(validModLines.length, validAddedLines.length);
                    
                    for (let i = 0; i < lineCount; i++) {
                        // Old version (removed)
                        const oldRow = document.createElement('div');
                        oldRow.className = 'unified-row modified removed';
                        oldRow.dataset.index = index;
                        oldRow.dataset.testid = 'unified-row';

                        const oldMarker = document.createElement('div');
                        oldMarker.className = 'unified-marker';
                        oldMarker.textContent = '~';

                        const oldLineNum = document.createElement('div');
                        oldLineNum.className = 'unified-line-num';
                        oldLineNum.textContent = '~' + prevLineNum++;

                        const oldContent = document.createElement('div');
                        oldContent.className = 'unified-content';

                        // Use inline highlighting if available
                        if (oldLineParts[i] && (modeToggles.words || modeToggles.chars)) {
                            oldContent.appendChild(renderInlineDiff(oldLineParts[i], 'previous', diffParts.isCharMode, change));
                        } else {
                            oldContent.textContent = validModLines[i] || '';
                        }

                        oldRow.appendChild(oldMarker);
                        oldRow.appendChild(oldLineNum);
                        oldRow.appendChild(oldContent);
                        fragment.appendChild(oldRow);

                        // New version (added)
                        const newRow = document.createElement('div');
                        newRow.className = 'unified-row modified added';
                        newRow.dataset.index = index;
                        newRow.dataset.testid = 'unified-row';

                        const newMarker = document.createElement('div');
                        newMarker.className = 'unified-marker';
                        newMarker.textContent = '~';

                        const newLineNum = document.createElement('div');
                        newLineNum.className = 'unified-line-num';
                        newLineNum.textContent = '~' + currLineNum++;

                        const newContent = document.createElement('div');
                        newContent.className = 'unified-content';

                        // Use inline highlighting if available
                        if (newLineParts[i] && (modeToggles.words || modeToggles.chars)) {
                            newContent.appendChild(renderInlineDiff(newLineParts[i], 'current', diffParts.isCharMode, change));
                        } else {
                            newContent.textContent = validAddedLines[i] || '';
                        }

                        newRow.appendChild(newMarker);
                        newRow.appendChild(newLineNum);
                        newRow.appendChild(newContent);
                        fragment.appendChild(newRow);
                    }
                } else if (classification === 'moved') {
                    // Simple moved line - show both source and destination
                    const movedRow = document.createElement('div');
                    movedRow.className = 'unified-row moved';
                    movedRow.dataset.index = index;
                    movedRow.dataset.testid = 'unified-row';

                    const marker = document.createElement('div');
                    marker.className = 'unified-marker';
                    marker.textContent = '→';

                    const lineNumDiv = document.createElement('div');
                    lineNumDiv.className = 'unified-line-num';
                    lineNumDiv.textContent = '→';

                    const content = document.createElement('div');
                    content.className = 'unified-content';
                    content.textContent = '→' + change.value;

                    movedRow.appendChild(marker);
                    movedRow.appendChild(lineNumDiv);
                    movedRow.appendChild(content);
                    fragment.appendChild(movedRow);

                    prevLineNum++;
                    currLineNum++;
                } else if (classification === 'block-moved') {
                    // Block move in unified view
                    // For normal moves: check removed/added flags
                    // For virtual moves from unchanged lines: check blockMoveSource/Destination
                    const isSource = change.removed || change.blockMoveSource !== undefined;
                    const isDestination = change.added || change.blockMoveDestination !== undefined;
                    const blockInfo = change.blockMoveInfo;
                    
                    // Determine if this is a modified block move (similarity < 0.99)
                    const isModified = blockInfo && blockInfo.similarity !== undefined && blockInfo.similarity < 0.99;
                    
                    // Split block content into individual lines
                    const blockLines = change.value.split('\n');
                    const validBlockLines = blockLines.filter((line, idx) => !(line === '' && idx === blockLines.length - 1));
                    
                    // Determine symbols and CSS classes
                    const sourceSymbol = isModified ? '≤' : '<';
                    const destSymbol = isModified ? '≥' : '>';
                    const sourceCssClass = isModified ? 'block-moved-from-modified' : 'block-moved-from';
                    const destCssClass = isModified ? 'block-moved-to-modified' : 'block-moved-to';
                    const sourceTooltip = isModified 
                        ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                        : `Block moved to line ${blockInfo.to + 1}`;
                    const destTooltip = isModified
                        ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                        : `Block moved from line ${blockInfo.from + 1}`;
                    
                    // Create a separate row for each line in the block
                    validBlockLines.forEach((line, idx) => {
                        const isFirstLine = idx === 0;
                        
                        if (isSource) {
                            // Source of block move
                            const sourceRow = document.createElement('div');
                            sourceRow.className = `unified-row ${sourceCssClass} block-moved-source block-moved-indicator`;
                            sourceRow.dataset.index = index;
                            sourceRow.dataset.testid = 'unified-row';

                            const marker = document.createElement('div');
                            marker.className = 'unified-marker';
                            marker.textContent = sourceSymbol;

                            const lineNumDiv = document.createElement('div');
                            lineNumDiv.className = 'unified-line-num';
                            lineNumDiv.textContent = prevLineNum;

                            const content = document.createElement('div');
                            content.className = 'unified-content';
                            content.textContent = line;

                            // Add tooltip to first row only
                            if (isFirstLine) sourceRow.title = sourceTooltip;

                            sourceRow.appendChild(marker);
                            sourceRow.appendChild(lineNumDiv);
                            sourceRow.appendChild(content);
                            fragment.appendChild(sourceRow);

                            prevLineNum++;
                        } else if (isDestination) {
                            // Destination of block move
                            const destRow = document.createElement('div');
                            destRow.className = `unified-row ${destCssClass} block-moved-destination block-moved-indicator`;
                            destRow.dataset.index = index;
                            destRow.dataset.testid = 'unified-row';

                            const marker = document.createElement('div');
                            marker.className = 'unified-marker';
                            marker.textContent = destSymbol;

                            const lineNumDiv = document.createElement('div');
                            lineNumDiv.className = 'unified-line-num';
                            lineNumDiv.textContent = currLineNum;

                            const content = document.createElement('div');
                            content.className = 'unified-content';
                            content.textContent = line;

                            // Add tooltip to first row only
                            if (isFirstLine) destRow.title = destTooltip;

                            destRow.appendChild(marker);
                            destRow.appendChild(lineNumDiv);
                            destRow.appendChild(content);
                            fragment.appendChild(destRow);

                            currLineNum++;
                        }
                    });
                }
            }

            unifiedDiffContent.appendChild(fragment);
        }

        // Switch between split and unified views
        async function switchView(view) {
            currentView = view;
            
            if (view === 'unified') {
                diffContainer.style.display = 'none';
                unifiedContainer.style.display = 'block';
                if (currentResults.length > 0) {
                    await renderUnifiedDiff(currentResults, currentStats);
                }
            } else {
                diffContainer.style.display = 'grid';
                unifiedContainer.style.display = 'none';
            }
        }
        
        // Render diff results with gap alignment
        async function renderDiffResults(results, stats) {
            currentResults = results;
            currentStats = stats;
            currentChangeIndex = -1;
            
            // Reset performance counters
            totalUnchangedLines = 0;
            syntaxHighlightingEnabled = true;
            
            // Check if we should disable syntax highlighting for performance
            const unchangedLineCount = results.filter(r => 
                (r.classification || (r.added ? 'added' : r.removed ? 'removed' : 'unchanged')) === 'unchanged'
            ).length;
            
            if (unchangedLineCount > SYNTAX_HIGHLIGHTING_MAX_LINES) {
                syntaxHighlightingEnabled = false;
                console.log(`Disabling syntax highlighting: ${unchangedLineCount} unchanged lines exceeds limit of ${SYNTAX_HIGHLIGHTING_MAX_LINES}`);
            }
            
            // Clear previous content
            previousDiffContent.innerHTML = '';
            currentDiffContent.innerHTML = '';
            
            // Create document fragments for batch insertion
            const prevFragment = document.createDocumentFragment();
            const currFragment = document.createDocumentFragment();
            
            let prevLineNum = 1;
            let currLineNum = 1;
            
            for (const [index, change] of results.entries()) {
                const classification = change.classification || (change.added ? 'added' : change.removed ? 'removed' : 'unchanged');

                // Skip the "added" side of a modified pair - we render both panels when processing the "removed" side
                if (classification === 'modified' && change.added) {
                    continue;
                }

                // Create previous panel row
                const prevRow = document.createElement('div');
                prevRow.className = 'diff-row';
                prevRow.dataset.index = index;
                prevRow.dataset.testid = 'diff-row';

                const prevLineNumDiv = document.createElement('div');
                prevLineNumDiv.className = 'line-number';

                const prevContentDiv = document.createElement('div');
                prevContentDiv.className = 'line-content';

                // Create current panel row
                const currRow = document.createElement('div');
                currRow.className = 'diff-row';
                currRow.dataset.index = index;
                currRow.dataset.testid = 'diff-row';

                const currLineNumDiv = document.createElement('div');
                currLineNumDiv.className = 'line-number';

                const currContentDiv = document.createElement('div');
                currContentDiv.className = 'line-content';

                let rowsAppended = false;

                switch (classification) {
                    case 'added': {
                        // Only in current - split into individual lines if grouped
                        // Check if this is actually a block move destination
                        const blockInfo = change.blockMoveInfo;
                        const isBlockMove = classification === 'block-moved' || (blockInfo && (change.blockMoveSource !== undefined || change.blockMoveDestination !== undefined));
                        const isModified = blockInfo && blockInfo.similarity !== undefined && blockInfo.similarity < 0.99;
                        
                        const addedLines = change.value.split('\n');
                        const validAddedLines = addedLines.filter((line, idx) => !(line === '' && idx === addedLines.length - 1));

                        if (validAddedLines.length === 1) {
                            // Single line - render with appropriate symbol
                            const symbol = isBlockMove ? (isModified ? '≥' : '>') : '+';
                            const cssClass = isBlockMove ? (isModified ? 'block-moved-to-modified' : 'block-moved-to') : 'added';
                            const tooltipText = isBlockMove
                                ? (isModified
                                    ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                                    : `Block moved from line ${blockInfo.from + 1}`)
                                : '';
                            
                            prevRow.classList.add('gap');
                            prevLineNumDiv.textContent = '';
                            prevContentDiv.classList.add('gap-placeholder');
                            prevContentDiv.textContent = ' ';

                            currRow.classList.add(cssClass, 'block-moved-destination', 'block-moved-indicator');
                            currLineNumDiv.textContent = symbol + currLineNum++;
                            currContentDiv.textContent = ' ' + validAddedLines[0];
                            if (tooltipText) currRow.title = tooltipText;
                        } else {
                            // Multiple lines - create separate rows for each
                            rowsAppended = true;
                            validAddedLines.forEach((line) => {
                                const prevRow = document.createElement('div');
                                prevRow.className = 'diff-row gap';
                                prevRow.dataset.index = index;
                                prevRow.dataset.testid = 'diff-row';
                                const prevLineNumDiv = document.createElement('div');
                                prevLineNumDiv.className = 'line-number';
                                const prevContentDiv = document.createElement('div');
                                prevContentDiv.className = 'line-content gap-placeholder';

                                const currRow = document.createElement('div');
                                currRow.className = 'diff-row added';
                                currRow.dataset.index = index;
                                currRow.dataset.testid = 'diff-row';
                                const currLineNumDiv = document.createElement('div');
                                currLineNumDiv.className = 'line-number';
                                const currContentDiv = document.createElement('div');
                                currContentDiv.className = 'line-content';

                                prevLineNumDiv.textContent = '';
                                prevContentDiv.textContent = ' ';

                            currLineNumDiv.textContent = '+' + currLineNum++;
                            currContentDiv.textContent = ' ' + line;

                                prevRow.appendChild(prevLineNumDiv);
                                prevRow.appendChild(prevContentDiv);
                                prevFragment.appendChild(prevRow);

                                currRow.appendChild(currLineNumDiv);
                                currRow.appendChild(currContentDiv);
                                currFragment.appendChild(currRow);
                            });
                        }
                        break;
                    }

                    case 'removed': {
                        // Only in previous - split into individual lines if grouped
                        // Check if this is actually a block move source
                        const blockInfo = change.blockMoveInfo;
                        const isBlockMove = classification === 'block-moved' || (blockInfo && (change.blockMoveSource !== undefined || change.blockMoveDestination !== undefined));
                        const isModified = blockInfo && blockInfo.similarity !== undefined && blockInfo.similarity < 0.99;
                        
                        const removedLines = change.value.split('\n');
                        const validRemovedLines = removedLines.filter((line, idx) => !(line === '' && idx === removedLines.length - 1));

                        if (validRemovedLines.length === 1) {
                            // Single line - render with appropriate symbol
                            const symbol = isBlockMove ? (isModified ? '≤' : '<') : '-';
                            const cssClass = isBlockMove ? (isModified ? 'block-moved-from-modified' : 'block-moved-from') : 'removed';
                            const tooltipText = isBlockMove 
                                ? (isModified 
                                    ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                                    : `Block moved to line ${blockInfo.to + 1}`)
                                : '';
                            
                            prevRow.classList.add(cssClass, 'block-moved-source', 'block-moved-indicator');
                            prevLineNumDiv.textContent = symbol + prevLineNum++;
                            prevContentDiv.textContent = ' ' + validRemovedLines[0];
                            if (tooltipText) prevRow.title = tooltipText;

                            currRow.classList.add('gap');
                            currLineNumDiv.textContent = '';
                            currContentDiv.classList.add('gap-placeholder');
                            currContentDiv.textContent = ' ';
                        } else {
                            // Multiple lines - create separate rows for each
                            rowsAppended = true; // We'll append rows manually for multi-line
                            for (let i = 0; i < validRemovedLines.length; i++) {
                                const line = validRemovedLines[i];
                                
                                const prevRow = document.createElement('div');
                                prevRow.className = 'diff-row';
                                prevRow.dataset.index = index;
                                prevRow.dataset.testid = 'diff-row';
                                const prevLineNumDiv = document.createElement('div');
                                prevLineNumDiv.className = 'line-number';
                                const prevContentDiv = document.createElement('div');
                                prevContentDiv.className = 'line-content';

                                prevLineNumDiv.textContent = prevLineNum++;
                                
                                // Apply syntax highlighting to unchanged lines in previous panel
                                const prevHighlightedLine = await renderUnchangedLine(' ' + line, detectedLanguage);
                                prevContentDiv.appendChild(prevHighlightedLine);

                                const currRow = document.createElement('div');
                                currRow.className = 'diff-row added';
                                currRow.dataset.index = index;
                                currRow.dataset.testid = 'diff-row';
                                const currLineNumDiv = document.createElement('div');
                                currLineNumDiv.className = 'line-number';
                                const currContentDiv = document.createElement('div');
                                currContentDiv.className = 'line-content';

                                currLineNumDiv.textContent = currLineNum++;
                                
                                // Apply syntax highlighting to unchanged lines in current panel
                                const currHighlightedLine = await renderUnchangedLine(' ' + line, detectedLanguage);
                                currContentDiv.appendChild(currHighlightedLine);

                                prevRow.appendChild(prevLineNumDiv);
                                prevRow.appendChild(prevContentDiv);
                                prevFragment.appendChild(prevRow);

                                currRow.appendChild(currLineNumDiv);
                                currRow.appendChild(currContentDiv);
                                currFragment.appendChild(currRow);
                            }
                        }
                        break;
                    }

                    case 'modified': {
                        // Modified line - show removed version in previous panel, added version in current panel
                        // Use the stored removedLine and addedLine values from the classified result
                        const removedLineValue = change.removedLine || change.value;
                        const addedLineValue = change.addedLine || change.value;

                        // Check if modified content spans multiple lines
                        const modLines = removedLineValue.split('\n');
                        const validModLines = modLines.filter((line, idx) => !(line === '' && idx === modLines.length - 1));
                        const addedLines = addedLineValue.split('\n');
                        const validAddedLines = addedLines.filter((line, idx) => !(line === '' && idx === addedLines.length - 1));

                        if (validModLines.length === 1) {
                            // Single line modified - render with ~ symbol
                            prevRow.classList.add('modified');
                            prevLineNumDiv.textContent = '~' + prevLineNum++;

                            currRow.classList.add('modified');
                            currLineNumDiv.textContent = '~' + currLineNum++;

                            // Use hybrid selection: char for small changes, word for larger changes
                            const diffParts = getDiffPartsForChange(change, removedLineValue, addedLineValue);
                            if (diffParts.parts && (modeToggles.words || modeToggles.chars)) {
                                // Show inline diff with hierarchical highlighting
                                prevContentDiv.appendChild(renderInlineDiff(diffParts.parts, 'previous', diffParts.isCharMode, change));
                                currContentDiv.appendChild(renderInlineDiff(diffParts.parts, 'current', diffParts.isCharMode, change));
                            } else {
                                // No inline highlighting - show plain text
                                prevContentDiv.textContent = ' ' + removedLineValue;
                                currContentDiv.textContent = ' ' + addedLineValue;
                            }
                        } else {
                            // Multi-line modified - create separate rows for each line pair with inline highlighting
                            rowsAppended = true;
                            
                            // Split the diff parts by lines for proper per-line highlighting
                            const diffParts = getDiffPartsForChange(change, removedLineValue, addedLineValue);
                            let prevLineParts = [];
                            let currLineParts = [];
                            
                            if (diffParts.parts && (modeToggles.words || modeToggles.chars)) {
                                // Split the diff parts by lines
                                prevLineParts = splitDiffPartsByLines(diffParts.parts, validModLines);
                                currLineParts = splitDiffPartsByLines(diffParts.parts, validAddedLines);
                            }
                            
                            const lineCount = Math.max(validModLines.length, validAddedLines.length);
                            for (let i = 0; i < lineCount; i++) {
                                const prevRow = document.createElement('div');
                                prevRow.className = 'diff-row modified';
                                prevRow.dataset.index = index;
                                prevRow.dataset.testid = 'diff-row';
                                const prevLineNumDiv = document.createElement('div');
                                prevLineNumDiv.className = 'line-number';
                                const prevContentDiv = document.createElement('div');
                                prevContentDiv.className = 'line-content';

                                const currRow = document.createElement('div');
                                currRow.className = 'diff-row modified';
                                currRow.dataset.index = index;
                                currRow.dataset.testid = 'diff-row';
                                const currLineNumDiv = document.createElement('div');
                                currLineNumDiv.className = 'line-number';
                                const currContentDiv = document.createElement('div');
                                currContentDiv.className = 'line-content';

prevLineNumDiv.textContent = '~' + prevLineNum++;
                            currLineNumDiv.textContent = '~' + currLineNum++;
                                
                                // Use inline highlighting if available, otherwise plain text
                                if (prevLineParts[i] && currLineParts[i]) {
                                    prevContentDiv.appendChild(renderInlineDiff(prevLineParts[i], 'previous', diffParts.isCharMode, change));
                                    currContentDiv.appendChild(renderInlineDiff(currLineParts[i], 'current', diffParts.isCharMode, change));
                                } else {
                                    prevContentDiv.textContent = ' ' + (validModLines[i] || '');
                                    currContentDiv.textContent = ' ' + (validAddedLines[i] || '');
                                }

                                prevRow.appendChild(prevLineNumDiv);
                                prevRow.appendChild(prevContentDiv);
                                prevFragment.appendChild(prevRow);

                                currRow.appendChild(currLineNumDiv);
                                currRow.appendChild(currContentDiv);
                                currFragment.appendChild(currRow);
                            }
                        }
                        break;
                    }

                    case 'moved': {
                        // Moved line
                        prevRow.classList.add('removed');
                        prevLineNumDiv.textContent = prevLineNum++;
                        prevContentDiv.textContent = '→' + change.value;

                        currRow.classList.add('added');
                        currLineNumDiv.textContent = currLineNum++;
                        currContentDiv.textContent = '→' + change.value;
                        break;
                    }

                    case 'block-moved': {
                        // Block move - enhanced handling with new visual indicators
                        // For normal moves: check removed/added flags
                        // For virtual moves from unchanged lines: check blockMoveSource/Destination
                        const isSource = change.removed || change.blockMoveSource !== undefined;
                        const isDestination = change.added || change.blockMoveDestination !== undefined;
                        const blockInfo = change.blockMoveInfo;
                        
                        // Determine if this is a modified block move (similarity < 0.99)
                        const isModified = blockInfo && blockInfo.similarity !== undefined && blockInfo.similarity < 0.99;
                        
                        // Split block content into individual lines
                        const blockLines = change.value.split('\n');
                        const validBlockLines = blockLines.filter((line, idx) => !(line === '' && idx === blockLines.length - 1));
                        
                        if (validBlockLines.length === 1) {
                            // Single line block - render normally (original behavior)
                            if (isSource) {
                                // Source of block move: use '<' for pure, '≤' for modified
                                const symbol = isModified ? '≤' : '<';
                                const cssClass = isModified ? 'block-moved-from-modified' : 'block-moved-from';
                                const tooltipText = isModified 
                                    ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                                    : `Block moved to line ${blockInfo.to + 1}`;
                                
                                prevRow.classList.add(cssClass, 'block-moved-source', 'block-moved-indicator');
prevLineNumDiv.textContent = symbol + prevLineNum++;
                                prevContentDiv.textContent = ' ' + change.value;
                                prevRow.title = tooltipText;
                                
                                // Current panel - no content (moved away)
                                currRow.classList.add('empty');
                                currLineNumDiv.textContent = '';
                                currContentDiv.textContent = '';
                            } else if (isDestination) {
                                // Destination of block move: use '>' for pure, '≥' for modified
                                const symbol = isModified ? '≥' : '>';
                                const cssClass = isModified ? 'block-moved-to-modified' : 'block-moved-to';
                                const tooltipText = isModified
                                    ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                                    : `Block moved from line ${blockInfo.from + 1}`;
                                
                                prevRow.classList.add('empty');
                                prevLineNumDiv.textContent = '';
                                prevContentDiv.textContent = '';
                                
                                currRow.classList.add(cssClass, 'block-moved-destination', 'block-moved-indicator');
currLineNumDiv.textContent = symbol + currLineNum++;
                                currContentDiv.textContent = ' ' + change.value;
                                currRow.title = tooltipText;
                            }
                        } else {
                            // Multiple lines - create separate rows for each line
                            rowsAppended = true;
                            const sourceSymbol = isModified ? '≤' : '<';
                            const destSymbol = isModified ? '≥' : '>';
                            const sourceCssClass = isModified ? 'block-moved-from-modified' : 'block-moved-from';
                            const destCssClass = isModified ? 'block-moved-to-modified' : 'block-moved-to';
                            const sourceTooltip = isModified 
                                ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                                : `Block moved to line ${blockInfo.to + 1}`;
                            const destTooltip = isModified
                                ? `Block moved and modified (similarity: ${Math.round((blockInfo.similarity || 0) * 100)}%)`
                                : `Block moved from line ${blockInfo.from + 1}`;
                            
                            validBlockLines.forEach((line, idx) => {
                                const isFirstLine = idx === 0;
                                
                                if (isSource) {
                                    // Source: show lines in previous panel, gaps in current
                                    const newPrevRow = document.createElement('div');
                                    newPrevRow.className = `diff-row ${sourceCssClass} block-moved-source block-moved-indicator`;
                                    newPrevRow.dataset.index = index;
                                    newPrevRow.dataset.testid = 'diff-row';
                                    const newPrevLineNum = document.createElement('div');
                                    newPrevLineNum.className = 'line-number';
                                    const newPrevContent = document.createElement('div');
                                    newPrevContent.className = 'line-content';
                                    
                                    newPrevLineNum.textContent = sourceSymbol + prevLineNum++;
                                    newPrevContent.textContent = ' ' + line;
                                    if (isFirstLine) newPrevRow.title = sourceTooltip;
                                    
                                    const newCurrRow = document.createElement('div');
                                    newCurrRow.className = 'diff-row gap';
                                    newCurrRow.dataset.index = index;
                                    newCurrRow.dataset.testid = 'diff-row';
                                    const newCurrLineNum = document.createElement('div');
                                    newCurrLineNum.className = 'line-number';
                                    const newCurrContent = document.createElement('div');
                                    newCurrContent.className = 'line-content gap-placeholder';
                                    
                                    newCurrRow.appendChild(newCurrLineNum);
                                    newCurrRow.appendChild(newCurrContent);
                                    currFragment.appendChild(newCurrRow);
                                    
                                    newPrevRow.appendChild(newPrevLineNum);
                                    newPrevRow.appendChild(newPrevContent);
                                    prevFragment.appendChild(newPrevRow);
                                } else if (isDestination) {
                                    // Destination: show gaps in previous panel, lines in current
                                    const newPrevRow = document.createElement('div');
                                    newPrevRow.className = 'diff-row gap';
                                    newPrevRow.dataset.index = index;
                                    newPrevRow.dataset.testid = 'diff-row';
                                    const newPrevLineNum = document.createElement('div');
                                    newPrevLineNum.className = 'line-number';
                                    const newPrevContent = document.createElement('div');
                                    newPrevContent.className = 'line-content gap-placeholder';
                                    
                                    const newCurrRow = document.createElement('div');
                                    newCurrRow.className = `diff-row ${destCssClass} block-moved-destination block-moved-indicator`;
                                    newCurrRow.dataset.index = index;
                                    newCurrRow.dataset.testid = 'diff-row';
                                    const newCurrLineNum = document.createElement('div');
                                    newCurrLineNum.className = 'line-number';
                                    const newCurrContent = document.createElement('div');
                                    newCurrContent.className = 'line-content';
                                    
                                    newCurrLineNum.textContent = destSymbol + currLineNum++;
                                    newCurrContent.textContent = ' ' + line;
                                    if (isFirstLine) newCurrRow.title = destTooltip;
                                    
                                    newPrevRow.appendChild(newPrevLineNum);
                                    newPrevRow.appendChild(newPrevContent);
                                    prevFragment.appendChild(newPrevRow);
                                    
                                    newCurrRow.appendChild(newCurrLineNum);
                                    newCurrRow.appendChild(newCurrContent);
                                    currFragment.appendChild(newCurrRow);
                                }
                            });
                        }
                        break;
                    }

                    default: {
                        // Unchanged - split into individual lines if grouped
                        const lines = change.value.split('\n');
                        // Keep all lines except the trailing empty string (from split on trailing newline)
                        const validLines = lines.filter((line, idx) => !(line === '' && idx === lines.length - 1));

                        if (validLines.length === 1) {
                            // Single line - render normally
                            prevLineNumDiv.textContent = prevLineNum++;
                            
                            // Apply syntax highlighting to unchanged lines in previous panel
                            const prevHighlightedContent = await renderUnchangedLine(' ' + validLines[0], detectedLanguage);
                            prevContentDiv.appendChild(prevHighlightedContent);

                            currLineNumDiv.textContent = currLineNum++;
                            
                            // Apply syntax highlighting to unchanged lines in current panel
                            const currHighlightedContent = await renderUnchangedLine(' ' + validLines[0], detectedLanguage);
                            currContentDiv.appendChild(currHighlightedContent);
                        } else if (validLines.length > 1) {
                            // Multiple lines - create separate rows for each
                            rowsAppended = true; // We'll append rows manually for multi-line
                            for (const line of validLines) {
                                const prevRow = document.createElement('div');
                                prevRow.className = 'diff-row';
                                prevRow.dataset.index = index;
                                prevRow.dataset.testid = 'diff-row';
                                const prevLineNumDiv = document.createElement('div');
                                prevLineNumDiv.className = 'line-number';
                                const prevContentDiv = document.createElement('div');
                                prevContentDiv.className = 'line-content';

                                const currRow = document.createElement('div');
                                currRow.className = 'diff-row';
                                currRow.dataset.index = index;
                                currRow.dataset.testid = 'diff-row';
                                const currLineNumDiv = document.createElement('div');
                                currLineNumDiv.className = 'line-number';
                                const currContentDiv = document.createElement('div');
                                currContentDiv.className = 'line-content';

                                prevLineNumDiv.textContent = prevLineNum++;
                                
                                // Apply syntax highlighting to unchanged lines in previous panel
                                const prevHighlightedLine = await renderUnchangedLine(' ' + line, detectedLanguage);
                                prevContentDiv.appendChild(prevHighlightedLine);

                                currLineNumDiv.textContent = currLineNum++;
                                
                                // Apply syntax highlighting to unchanged lines in current panel
                                const currHighlightedLine = await renderUnchangedLine(' ' + line, detectedLanguage);
                                currContentDiv.appendChild(currHighlightedLine);

                                prevRow.appendChild(prevLineNumDiv);
                                prevRow.appendChild(prevContentDiv);
                                prevFragment.appendChild(prevRow);

                                currRow.appendChild(currLineNumDiv);
                                currRow.appendChild(currContentDiv);
                                currFragment.appendChild(currRow);
                            }
                        }
                        break;
                    }
                }

                // Append rows for all cases except multi-line unchanged (which handles its own appending)
                if (!rowsAppended) {
                    prevRow.appendChild(prevLineNumDiv);
                    prevRow.appendChild(prevContentDiv);
                    prevFragment.appendChild(prevRow);

                    currRow.appendChild(currLineNumDiv);
                    currRow.appendChild(currContentDiv);
                    currFragment.appendChild(currRow);
                }
            }

            // Batch insert
            previousDiffContent.appendChild(prevFragment);
            currentDiffContent.appendChild(currFragment);
            
            // Show results based on current view
            if (currentView === 'unified') {
                diffContainer.style.display = 'none';
                unifiedContainer.style.display = 'block';
                await renderUnifiedDiff(results, stats);
            } else {
                diffContainer.style.display = 'grid';
                unifiedContainer.style.display = 'none';
            }
            
            navigationSection.style.display = 'flex';
            exportControls.style.display = 'flex';
            
            // Update stats
            updateStats(stats);
            
            // Setup scroll sync
            setupScrollSync();
            
            // Update navigation
            updateNavigation();
        }
        
        // Generate unified diff format from results
        function generateUnifiedDiff(results, stats) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            let output = `--- previous\t${timestamp}\n`;
            output += `+++ current\t${timestamp}\n`;
            output += `@@ -1,${results.filter(r => !r.added).length} +1,${results.filter(r => !r.removed).length} @@\n`;
            
            results.forEach(change => {
                const classification = change.classification || (change.added ? 'added' : change.removed ? 'removed' : 'unchanged');
                
                switch (classification) {
                    case 'added':
                        output += '+' + change.value + '\n';
                        break;
                    case 'removed':
                        output += '-' + change.value + '\n';
                        break;
                    case 'modified':
                        // Show both old and new versions
                        output += '-' + change.value + '\n';
                        output += '+' + (change.addedLine || change.value) + '\n';
                        break;
                    default:
                        output += ' ' + change.value + '\n';
                }
            });
            
            return output;
        }
        
        // Copy diff to clipboard
        async function copyToClipboard() {
            if (currentResults.length === 0) return;
            
            const diffText = generateUnifiedDiff(currentResults, currentStats);
            
            try {
                await navigator.clipboard.writeText(diffText);
                
                // Show success feedback
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                copyBtn.disabled = true;
                
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Failed to copy:', error);
                handleError('Clipboard', 'Failed to copy to clipboard. Please try again.', { error });
            }
        }
        
        // Download diff as .patch file
        function downloadPatch() {
            if (currentResults.length === 0) return;
            
            const diffText = generateUnifiedDiff(currentResults, currentStats);
            const blob = new Blob([diffText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `diff-${new Date().toISOString().slice(0, 10)}.patch`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Setup synchronized scrolling
        function setupScrollSync() {
            let isScrolling = false;
            
            function syncScroll(source, target) {
                if (isScrolling) return;
                isScrolling = true;
                target.scrollTop = source.scrollTop;
                requestAnimationFrame(() => {
                    isScrolling = false;
                });
            }
            
            previousDiffPanel.addEventListener('scroll', () => {
                syncScroll(previousDiffPanel, currentDiffPanel);
            });
            
            currentDiffPanel.addEventListener('scroll', () => {
                syncScroll(currentDiffPanel, previousDiffPanel);
            });
        }
        
        // Update navigation UI
        function updateNavigation() {
            const totalChanges = (currentStats?.added || 0) + (currentStats?.removed || 0) + (currentStats?.modified || 0);
            
            if (totalChanges === 0) {
                changeCounter.textContent = '0 of 0';
                prevChangeBtn.disabled = true;
                nextChangeBtn.disabled = true;
                return;
            }
            
            // Count actual change groups
            let changeGroups = 0;
            let inChange = false;
            
            currentResults.forEach(change => {
                const classification = change.classification || (change.added ? 'added' : change.removed ? 'removed' : 'unchanged');
                if (classification !== 'unchanged') {
                    if (!inChange) {
                        changeGroups++;
                        inChange = true;
                    }
                } else {
                    inChange = false;
                }
            });
            
            const currentGroup = Math.max(1, currentChangeIndex + 1);
            changeCounter.textContent = `${currentGroup} of ${changeGroups}`;
            
            prevChangeBtn.disabled = currentChangeIndex <= 0;
            nextChangeBtn.disabled = currentChangeIndex >= changeGroups - 1;
        }
        
        // Navigate to change
        function navigateToChange(direction) {
            let rows;
            let scrollContainer;
            
            if (currentView === 'unified') {
                rows = unifiedDiffContent.querySelectorAll('.unified-row');
                scrollContainer = document.getElementById('unified-diff-panel');
            } else {
                rows = previousDiffContent.querySelectorAll('.diff-row');
                scrollContainer = previousDiffPanel;
            }
            
            const totalRows = rows.length;
            
            if (totalRows === 0) return;
            
            // Find all change indices
            const changeIndices = [];
            let lastWasChange = false;
            
            rows.forEach((row, index) => {
                const isChange = row.classList.contains('added') || 
                                row.classList.contains('removed') || 
                                row.classList.contains('modified');
                
                if (isChange && !lastWasChange) {
                    changeIndices.push(index);
                }
                
                lastWasChange = isChange;
            });
            
            if (changeIndices.length === 0) return;
            
            // Update index
            if (direction === 'next') {
                currentChangeIndex = Math.min(currentChangeIndex + 1, changeIndices.length - 1);
            } else {
                currentChangeIndex = Math.max(currentChangeIndex - 1, 0);
            }
            
            // Scroll to change
            const targetIndex = changeIndices[currentChangeIndex];
            const targetRow = rows[targetIndex];
            
            if (targetRow) {
                const offset = targetRow.offsetTop - scrollContainer.offsetTop - 20;
                scrollContainer.scrollTop = offset;
                
                // For split view, sync both panels
                if (currentView !== 'unified') {
                    currentDiffPanel.scrollTop = offset;
                }
            }
            
            updateNavigation();
        }
        
        // Perform comparison
        async function performComparison() {
            const oldText = previousText.value;
            const newText = currentText.value;
            
            if (!oldText && !newText) {
                handleError('Input Validation', 'Please enter text in at least one panel');
                return;
            }
            
            // Check file sizes
            const totalSize = oldText.length + newText.length;
            if (totalSize > LIMITS.MAX_FILE_SIZE) {
                handleError('File Size', `Combined text exceeds ${LIMITS.MAX_FILE_SIZE / 1024 / 1024}MB limit. Please compare smaller sections.`);
                return;
            }
            
            // Detect language for syntax highlighting (use previous text as primary source)
            const combinedText = oldText || newText;
            detectedLanguage = detectLanguage('', combinedText);
            
            // Hide any previous limit warning
            limitWarning.classList.add('hidden');
            
            // Show progress
            const progress = showProgressModal();
            
            // Initialize worker if needed
            initWorker();
            
            const comparisonStartTime = performance.now();
            
            try {
                const filterOptions = {
                    ignoreWhitespace: ignoreWhitespaceCheckbox?.checked || false,
                    ignoreComments: ignoreCommentsCheckbox?.checked || false
                };
                
                // Prepare AST features for AST-aware comparison (main thread handles Tree-sitter)
                const astFeatures = await prepareDiffWithAST(oldText, newText, detectedLanguage);
                if (astFeatures) {
                    console.log('[Main] Passing AST features to worker for enhanced comparison');
                }

                const result = await diffWorker.compare(oldText, newText, {
                    modeToggles: modeToggles,
                    detectMoves: true,
                    filterOptions,
                    config: currentConfig,
                    astFeatures: astFeatures, // Pass pre-computed AST features
                    normalizeDelimiters: normalizeDelimitersCheckbox?.checked || false,
                    correctSliders: correctSlidersCheckbox?.checked || false
                });

                // Validate the result before rendering
                const validation = validateComparisonResult(result);
                if (!validation.isValid) {
                    throw new Error(`Invalid comparison result: ${validation.error}`);
                }
                
                // Check for timeout
                if (checkForTimeout(comparisonStartTime)) {
                    console.warn('[Main] Comparison completed but took longer than expected');
                }

                // Check for complexity limit warnings
                if (result.limitInfo?.fastMode) {
                    showLimitWarning(result.limitInfo);
                }

                // Update slider statistics if available
                if (result.sliders) {
                    updateSliderStats(result.sliders);
                }

                // Log successful comparison
                console.log('[Main] Comparison completed successfully:', {
                    duration: `${(performance.now() - comparisonStartTime).toFixed(2)}ms`,
                    resultCount: result.results.length,
                    stats: result.stats
                });

                // Render results to the appropriate view
                if (currentView === 'unified') {
                    await renderUnifiedDiff(result.results, result.stats);
                } else {
                    await renderDiffResults(result.results, result.stats);
                }
            } catch (error) {
                handleError('Comparison', error, {
                    oldTextLength: oldText.length,
                    newTextLength: newText.length,
                    duration: `${(performance.now() - comparisonStartTime).toFixed(2)}ms`
                });
            } finally {
                progress.close();
            }
        }
        
        /**
         * Update slider statistics and status display
         * @param {Array} sliderData - Array of slider correction data
         */
        function updateSliderStats(sliderData) {
            if (sliderData && sliderData.length > 0) {
                sliderStat.style.display = 'block';
                statSliders.textContent = sliderData.length;
                sliderStatus.style.display = 'block';
                sliderIndicator.style.display = 'inline-block';
                sliderMessage.textContent = `Auto-corrected ${sliderData.length} sliders`;
            } else {
                sliderStat.style.display = 'none';
                sliderStatus.style.display = 'none';
            }
        }
        
        // File Type Detection
        const EXTENSION_MAP = {
            '.json': 'json',
            '.yaml': 'yaml', '.yml': 'yaml',
            '.xml': 'xml',
            '.txt': 'text',
            '.md': 'markdown',
            '.js': 'javascript',
            '.py': 'python',
            '.c': 'c',
            '.h': 'c-header',
            '.cpp': 'cpp',
            '.hpp': 'cpp-header',
            '.java': 'java',
            '.go': 'go',
            '.rs': 'rust',
            '.rb': 'ruby',
            '.php': 'php',
            '.sh': 'bash',
            '.ps1': 'powershell',
            '.sql': 'sql',
            '.css': 'css',
            '.html': 'html',
            '.htm': 'html',
            '.conf': 'config',
            '.cfg': 'config',
            '.ini': 'ini',
            '.toml': 'toml',
            '.log': 'log'
        };

        function detectFileType(content, filename = '') {
            // Level 1: Extension-based detection
            const ext = filename.split('.').pop().toLowerCase();
            if (EXTENSION_MAP['.' + ext]) {
                return EXTENSION_MAP['.' + ext];
            }

            // Level 2: Content-based detection for network configs
            if (isCiscoIOS(content)) return 'cisco-ios';
            if (isJuniperJunOS(content)) return 'juniper-junos';
            if (isAristaEOS(content)) return 'arista-eos';

            // Level 3: Content-based detection for code/data formats
            if (isJSON(content)) return 'json';
            if (isXML(content)) return 'xml';
            if (isYAML(content)) return 'yaml';

            return 'text';
        }

        function isCiscoIOS(content) {
            const ciscoPatterns = [
                /^\s*!/m,
                /^interface\s+/m,
                /^hostname\s+/m,
                /^line\s+(console|vty)/m,
                /^router\s+/m,
                /^version\s+\d+\.\d+/m
            ];
            return ciscoPatterns.some(pattern => pattern.test(content.slice(0, 5000)));
        }

        function isJuniperJunOS(content) {
            // Require at least 2 JunOS-specific patterns to avoid false positives
            // The curly brace pattern alone matches Python dicts, JS objects, etc.
            const junosPatterns = [
                /^set\s+/m,              // set commands
                /^system\s*\{/m,         // system { ... }
                /^interfaces\s*\{/m,     // interfaces { ... }
                /^routing-options\s*\{/m, // routing-options { ... }
                /^(edit|configure)\s+/m, // edit or configure commands
                /^show\s+(configuration|interfaces)/m // show commands
            ];
            const sample = content.slice(0, 5000);
            const matches = junosPatterns.filter(pattern => pattern.test(sample));
            // Require at least 2 patterns to confirm JunOS
            return matches.length >= 2;
        }

        function isAristaEOS(content) {
            return isCiscoIOS(content) && /\barista\b/i.test(content.slice(0, 5000));
        }

        function isJSON(content) {
            const trimmed = content.trim();
            return (trimmed.startsWith('{') && trimmed.endsWith('}')) ||
                   (trimmed.startsWith('[') && trimmed.endsWith(']'));
        }

        function isXML(content) {
            const trimmed = content.trim();
            return trimmed.startsWith('<?xml') ||
                   trimmed.startsWith('<!DOCTYPE') ||
                   /^<[a-zA-Z][\s\S]*?>/.test(trimmed);
        }

        function isYAML(content) {
            const lines = content.split('\n').slice(0, 50);
            return lines.some(line =>
                line.startsWith('---') ||
                /^[a-zA-Z_][a-zA-Z0-9_]*\s*:/.test(line) ||
                /^\s*-\s+/.test(line)
            );
        }

        function formatFileType(fileType) {
            const typeLabels = {
                'json': 'JSON',
                'yaml': 'YAML',
                'xml': 'XML',
                'text': 'Plain Text',
                'markdown': 'Markdown',
                'javascript': 'JavaScript',
                'python': 'Python',
                'c': 'C',
                'c-header': 'C Header',
                'cpp': 'C++',
                'cpp-header': 'C++ Header',
                'java': 'Java',
                'go': 'Go',
                'rust': 'Rust',
                'ruby': 'Ruby',
                'php': 'PHP',
                'bash': 'Bash',
                'powershell': 'PowerShell',
                'sql': 'SQL',
                'css': 'CSS',
                'html': 'HTML',
                'config': 'Config',
                'ini': 'INI',
                'toml': 'TOML',
                'log': 'Log',
                'cisco-ios': 'Cisco IOS',
                'juniper-junos': 'Juniper JunOS',
                'arista-eos': 'Arista EOS'
            };
            return typeLabels[fileType] || fileType;
        }

        function isBinaryFile(content) {
            // Check for non-printable characters in first 1000 chars
            return /[^\x20-\x7E\s]/.test(content.slice(0, 1000));
        }

        // File handling
        function handleFileDrop(event, textarea, fileInfo) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');

            const file = event.dataTransfer.files[0];
            if (!file) return;

            // Check file size
            if (file.size > LIMITS.MAX_FILE_SIZE) {
                handleError('File Upload', `File exceeds ${LIMITS.MAX_FILE_SIZE / 1024 / 1024}MB limit. Please use a smaller file.`, { fileSize: file.size });
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;

                // Check for binary files
                if (isBinaryFile(content)) {
                    handleError('File Upload', 'Binary files cannot be compared. Please use text files only.', { fileName: file.name });
                    return;
                }

                textarea.value = content;
                const fileType = detectFileType(content, file.name);
                const formattedType = formatFileType(fileType);
                fileInfo.textContent = `${file.name} (${formatFileSize(file.size)}) - ${formattedType}`;
            };
            reader.onerror = () => {
                handleError('File Upload', 'Error reading file. Please try again.', { fileName: file.name, error: reader.error });
            };
            reader.readAsText(file);
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        // Event Listeners
        configToggleBtn.addEventListener('click', toggleConfigPanel);
        configCloseBtn.addEventListener('click', toggleConfigPanel);
        saveConfigBtn.addEventListener('click', saveConfig);
        resetConfigBtn.addEventListener('click', resetConfig);
        helpBtn.addEventListener('click', () => window.showHelp());
        aboutBtn.addEventListener('click', () => window.showAbout());

        // Close config panel with Escape key
        configPanel.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (!configPanel.classList.contains('hidden')) {
                    toggleConfigPanel();
                }
            }
        });
        
        compareBtn.addEventListener('click', performComparison);
        
        clearBtn.addEventListener('click', () => {
            previousText.value = '';
            currentText.value = '';
            previousFileInfo.textContent = '';
            currentFileInfo.textContent = '';
            diffContainer.style.display = 'none';
            navigationSection.style.display = 'none';
            exportControls.style.display = 'none';
            sliderStat.style.display = 'none';
            sliderStatus.style.display = 'none';
            updateStats({ added: 0, removed: 0, modified: 0 });
        });
        
        swapBtn.addEventListener('click', () => {
            const temp = previousText.value;
            previousText.value = currentText.value;
            currentText.value = temp;
            
            const tempInfo = previousFileInfo.textContent;
            previousFileInfo.textContent = currentFileInfo.textContent;
            currentFileInfo.textContent = tempInfo;
        });
        
        prevChangeBtn.addEventListener('click', () => navigateToChange('prev'));
        nextChangeBtn.addEventListener('click', () => navigateToChange('next'));
        
        // Mode toggle - individual toggles for each mode
        modeButtons.forEach(btn => {
            btn.addEventListener('click', async () => {
                const mode = btn.dataset.mode;
                const isActive = btn.classList.contains('active');

                // Toggle the mode state
                modeToggles[mode] = !isActive;

                // Update button appearance
                if (isActive) {
                    btn.classList.remove('active');
                    btn.setAttribute('aria-pressed', 'false');
                } else {
                    btn.classList.add('active');
                    btn.setAttribute('aria-pressed', 'true');
                }

                // Re-render if we have results (no need to re-run comparison)
                if (currentResults.length > 0) {
                    await renderDiffResults(currentResults, currentStats);
                }
            });
        });

        // View toggle (split/unified)
        viewButtons.forEach(btn => {
            btn.addEventListener('click', async () => {
                viewButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const view = btn.dataset.view;
                await switchView(view);
            });
        });
        
        // Drag and drop
        const previousPanelDrop = document.getElementById('previous-panel-drop');
        const currentPanelDrop = document.getElementById('current-panel-drop');
        
        [previousPanelDrop, currentPanelDrop].forEach(panel => {
            panel.addEventListener('dragover', (e) => {
                e.preventDefault();
                panel.classList.add('drag-over');
            });
            
            panel.addEventListener('dragleave', () => {
                panel.classList.remove('drag-over');
            });
            
            panel.addEventListener('drop', (e) => {
                const textarea = panel.querySelector('textarea');
                const fileInfo = panel.querySelector('.file-info');
                handleFileDrop(e, textarea, fileInfo);
            });
        });

        // Paste handling for file type detection
        previousText.addEventListener('paste', (e) => {
            // Use setTimeout to get the pasted content after it's inserted
            setTimeout(() => {
                const content = previousText.value;
                const fileType = detectFileType(content);
                const formattedType = formatFileType(fileType);
                previousFileInfo.textContent = `(${formattedType})`;
            }, 0);
        });

        currentText.addEventListener('paste', (e) => {
            setTimeout(() => {
                const content = currentText.value;
                const fileType = detectFileType(content);
                const formattedType = formatFileType(fileType);
                currentFileInfo.textContent = `(${formattedType})`;
            }, 0);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + Enter to compare
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                performComparison();
            }
            
            // Alt + Up/Down for navigation
            if (e.altKey && e.key === 'ArrowDown') {
                e.preventDefault();
                navigateToChange('next');
            }
            if (e.altKey && e.key === 'ArrowUp') {
                e.preventDefault();
                navigateToChange('prev');
            }
            
            // Ctrl/Cmd + Shift + C to copy diff
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                copyToClipboard();
            }
          });
        
        // Modal functions
        
        function showModal(title, content) {
            // Remove any existing modal
            closeModal();
            
            // Create modal overlay
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', 'modal-title');
            
            // Create modal content
            modal.innerHTML = `
                <div class="modal-content" style="
                    background: white;
                    padding: 30px;
                    border-radius: 8px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    position: relative;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                ">
                    <button onclick="closeModal()" aria-label="Close modal" style="
                        position: absolute;
                        top: 15px;
                        right: 15px;
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">×</button>
                    <h2 id="modal-title" style="margin-top: 0; padding-right: 40px;">${title}</h2>
                    <div class="modal-body">${content}</div>
                </div>
            `;
            
            // Style the modal overlay
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            // Close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // Close on Escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
            
            document.body.appendChild(modal);
        }
        
        function closeModal() {
            const modal = document.querySelector('.modal');
            if (modal) {
                document.body.removeChild(modal);
            }
        }
        
        // Help and About modal functions
        window.showHelp = function() {
            const helpContent = `
<h2>Text Diff Tool Help</h2>
<p><strong>How to use:</strong></p>
<ol>
<li>Paste or drop the <strong>previous version</strong> text into the left panel</li>
<li>Paste or drop the <strong>current version</strong> text into the right panel</li>
<li>Click <strong>Compare</strong> to see the differences</li>
<li>Use the navigation buttons to jump between changes</li>
<li>Export the diff as a .patch file or copy to clipboard</li>
</ol>
<p><strong>Keyboard shortcuts:</strong></p>
<ul>
<li><kbd>Ctrl/Cmd</kbd> + <kbd>Enter</kbd> - Compare</li>
<li><kbd>Alt</kbd> + <kbd>↑</kbd> / <kbd>↓</kbd> - Navigate changes</li>
<li><kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd> - Copy diff to clipboard</li>
</ul>
<p><strong>Diff Mode Toggles:</strong></p>
<ul>
<li><strong>Line</strong> - Show which lines changed (light highlighting)</li>
<li><strong>Word</strong> - Highlight changed words within modified lines</li>
<li><strong>Char</strong> - Highlight individual character changes (most detailed)</li>
</ul>
<p><em>All three modes work together. Toggle them on/off to adjust highlighting detail.</em></p>
<p><strong>Color legend:</strong></p>
<ul>
<li><span style="color: #dc3545;">Red</span> - Content removed from previous version</li>
<li><span style="color: #28a745;">Green</span> - Content added in current version</li>
<li><span style="color: #ffc107;">Yellow/Orange</span> - Modified lines with inline highlighting</li>
</ul>
            `;
            showModal('Help', helpContent);
        };
        
        window.showAbout = function() {
            const aboutContent = `
<h2>About Text Diff Tool</h2>
<p>A free, private, client-side tool for comparing text, code, and configuration files with semantic highlighting.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>100% Private</strong> - Your files never leave your browser</li>
<li><strong>No Signup Required</strong> - Use instantly without creating an account</li>
<li><strong>Code & Config Support</strong> - Compare source code, JSON, YAML, XML, and more</li>
<li><strong>Large File Support</strong> - Handles files up to 10,000+ lines</li>
<li><strong>Multiple Views</strong> - Split and unified diff views</li>
<li><strong>Granular Diff</strong> - Character-level and word-level highlighting</li>
<li><strong>Export Options</strong> - Download as .patch or copy to clipboard</li>
<li><strong>Accessible</strong> - Screen reader support and keyboard navigation</li>
</ul>
<p><strong>Technology:</strong></p>
<p>Built with vanilla JavaScript using the <a href="https://github.com/kpdecker/jsdiff" target="_blank" rel="noopener">jsdiff</a> library. All processing happens in your browser via Web Workers.</p>
<p>&copy; 2025 Jason Tally and contributors. Licensed under MIT.</p>
            <p>Version: <span id="version-display">0.1.14</span></p>
            `;
            showModal('About', aboutContent);
        };
    </script>
    <footer>
        <div style="text-align: center; margin-top: 20px; padding: 10px; border-top: 1px solid #e0e0e0; font-size: 12px; color: #666;">
            Version: <span id="version-display">0.1.14</span>
        </div>
    </footer>
</body>
</html>
